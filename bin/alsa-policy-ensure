#!/usr/bin/env bash
set -euo pipefail

# alsa-policy-ensure: Generate a deterministic ALSA default chain and decide the anchor rate.
#
# - Probes the selected hardware device (prefers USB via bin/alsa-probe) for rates and formats.
# - Chooses one of two modes:
#     - 44.1-anchored (default): if the DAC supports 44100 Hz natively.
#     - 48-anchored+soxr: if 44.1 is not supported or if forced via env.
# - Emits /etc/asound.conf with chain: plug -> softvol -> dmix -> hw
#     - Anchors dmix at the selected rate
#     - Selects a robust format: prefer S32_LE, then S24_LE/S24_3LE, else S16_LE
# - Writes/updates /var/lib/airplay_wyse/alsa-policy.json (fingerprint + mode)
# - Prints a compact JSON summary to stdout with fields: anchor_hz, mode, hw, card_id, card_num, dev_num, format, usb, soxr_required
#
# Idempotent: if the fingerprint is unchanged and /etc/asound.conf matches, it does nothing.
#
# Env overrides:
#   ALSA_FORCE_ANCHOR=44100|48000   Force a specific anchor rate
#   ALSA_HW=hw:1,0                  Force a specific hardware device for probing
#

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
STATE_DIR="/var/lib/airplay_wyse"
FPR_JSON="$STATE_DIR/alsa-policy.json"
ASOUND_CONF="/etc/asound.conf"

log() { echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] [alsa-policy] $*"; }
die() { echo "[alsa-policy] ERROR: $*" >&2; exit 1; }

require_root() { [[ "$(id -u)" -eq 0 ]] || die "must be run as root"; }

have_cmd() { command -v "$1" >/dev/null 2>&1; }

json_escape() { printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'; }

ensure_state_dir() { install -d -m 0755 "$STATE_DIR"; }

amixer_present() { command -v amixer >/dev/null 2>&1; }

amixer_try_set() {
  local card="$1" control="$2"
  shift 2
  amixer_present || return 1
  local value
  for value in "$@"; do
    if amixer -c "$card" sset "$control" "$value" >/dev/null 2>&1; then
      return 0
    fi
  done
  return 1
}

configure_analog_controls() {
  local card="$1" usb_flag="$2"
  [[ "$usb_flag" == "1" ]] && return 0
  amixer_present || return 0
  local touched=0
  if amixer_try_set "$card" "Auto-Mute Mode" Enabled; then touched=1; fi
  if amixer_try_set "$card" "Headphone Playback Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "Headphone Playback Volume" 90% unmute; then touched=1; fi
  if amixer_try_set "$card" "Headphone Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "Headphone Volume" 90% unmute; then touched=1; fi
  if amixer_try_set "$card" "Line Out Playback Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "Line Out Playback Volume" 90% unmute; then touched=1; fi
  if amixer_try_set "$card" "Line Out Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "Line Out Volume" 90% unmute; then touched=1; fi
  if amixer_try_set "$card" "Speaker Playback Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "Speaker Playback Volume" 90% unmute; then touched=1; fi
  if amixer_try_set "$card" "Master Playback Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "Master Playback Volume" 90% unmute; then touched=1; fi
  if amixer_try_set "$card" "PCM Playback Switch" on unmute; then touched=1; fi
  if amixer_try_set "$card" "PCM Playback Volume" 90% unmute; then touched=1; fi
  if [[ $touched -eq 1 ]]; then
    log "configured analog playback controls on card $card"
  fi
}

probe_hw_from_repo() {
  if [[ -n "${ALSA_HW:-}" ]]; then
    echo "$ALSA_HW"; return 0
  fi
  local candidate d
  for candidate in "$SCRIPT_DIR/alsa-probe" "$REPO_DIR/bin/alsa-probe"; do
    if [[ -x "$candidate" ]]; then
      d="$($candidate 2>/dev/null || true)"
      d="${d/plughw:/hw:}"
      if [[ "$d" =~ ^hw:[0-9]+,[0-9]+$ ]]; then
        echo "$d"; return 0
      fi
    fi
  done
  # Fallback to hw:0,0
  echo "hw:0,0"
}

card_dev_from_hw() {
  # Input: hw:card,dev
  local hw="$1"
  local c d
  c=$(echo "$hw" | awk -F'[:,]' '{print $2}')
  d=$(echo "$hw" | awk -F'[:,]' '{print $3}')
  [[ -n "$c" && -n "$d" ]] || return 1
  echo "$c $d"
}

is_usb_card() {
  local card_num="$1" d
  d=$(readlink -f "/sys/class/sound/card${card_num}/device" 2>/dev/null || true)
  [[ -n "$d" && -f "$d/idVendor" && -f "$d/idProduct" ]]
}

usb_vidpid() {
  local card_num="$1" d
  d=$(readlink -f "/sys/class/sound/card${card_num}/device" 2>/dev/null || true)
  if [[ -n "$d" && -f "$d/idVendor" && -f "$d/idProduct" ]]; then
    printf '0x%s 0x%s' "$(tr '[:lower:]' '[:upper:]' <"$d/idVendor")" "$(tr '[:lower:]' '[:upper:]' <"$d/idProduct")"
  fi
}

card_id_from_num() { cat "/proc/asound/card$1/id" 2>/dev/null || true; }

parse_usb_rates() {
  # Returns space-separated numeric rates seen in stream* files
  local card_num="$1" f
  for f in /proc/asound/card${card_num}/stream*; do
    [[ -f "$f" ]] || continue
    awk '/Rates:/{ gsub(/\r/, ""); gsub(/,/ ," "); for(i=2;i<=NF;i++) { if ($i ~ /^[0-9]+$/) printf("%s ", $i); } }' "$f"
  done | tr ' ' '\n' | awk '!seen[$0]++ && $0!=""' | xargs echo || true
}

parse_usb_formats() {
  # Returns prioritized list of formats seen in stream* files
  local card_num="$1" f
  for f in /proc/asound/card${card_num}/stream*; do
    [[ -f "$f" ]] || continue
    awk '/Format:/{ for(i=2;i<=NF;i++) printf("%s ", $i) }' "$f"
  done | tr ' ' '\n' | awk '!seen[$0]++ && $0!=""' | xargs echo || true
}

aplay_opens() {
  local hw="$1" rate="$2" format="$3"
  # Try to open device for a very short time; avoid audio output if possible
  timeout 2 aplay -D "$hw" -r "$rate" -f "$format" -c 2 -t raw /dev/zero -d 0 >/dev/null 2>&1 || \
  timeout 2 aplay -D "$hw" -r "$rate" -f "$format" -c 2 -t raw /dev/zero -d 0.05 -q >/dev/null 2>&1
}

decide_anchor_and_format() {
  local hw="$1" card_num="$2" dev_num="$3" usb="$4"
  local force="${ALSA_FORCE_ANCHOR:-}" rates formats fmt anchor soxr_req
  soxr_req=0

  if [[ "$usb" == "1" ]]; then
    rates=$(parse_usb_rates "$card_num" || true)
    formats=$(parse_usb_formats "$card_num" || true)
  else
    rates=""
    formats=""
  fi

  # Decide format preference
  fmt=""
  for try in S32_LE S24_LE S24_3LE S16_LE; do
    if [[ -n "$formats" && " $formats " == *" $try "* ]]; then fmt="$try"; break; fi
  done
  if [[ -z "$fmt" ]]; then
    # Fall back to probing common formats
    for try in S32_LE S16_LE; do
      if aplay_opens "$hw" 48000 "$try" || aplay_opens "$hw" 44100 "$try"; then fmt="$try"; break; fi
    done
  fi
  [[ -n "$fmt" ]] || fmt="S16_LE"

  # Decide anchor rate
  if [[ "$force" == "44100" || "$force" == "48000" ]]; then
    anchor="$force"
  else
    if [[ -n "$rates" ]]; then
      if [[ " $rates " == *" 44100 "* ]]; then anchor=44100; else anchor=48000; fi
    else
      if aplay_opens "$hw" 44100 "$fmt"; then anchor=44100; else anchor=48000; fi
    fi
  fi

  if [[ "$anchor" == "48000" ]]; then soxr_req=1; fi
  printf '%s %s %s' "$anchor" "$fmt" "$soxr_req"
}

render_asound_conf() {
  local path="$1" card_id="$2" card_num="$3" dev_num="$4" anchor="$5" fmt="$6"
  local ipc_key=$(( 0x$(echo -n "$card_id$dev_num" | md5sum 2>/dev/null | awk '{print substr($1,1,6)}') ))
  : "${ipc_key:=567829}"
  cat >"$path" <<EOF
# Managed by AirPlay Wyse (bin/alsa-policy-ensure)
# Anchor: ${anchor} Hz; Chain: plug -> softvol -> dmix -> hw
# Card: ${card_id} (index ${card_num}, device ${dev_num}); Mix format: ${fmt}

pcm._aw_hw {
  type hw
  card "${card_id}"
  device ${dev_num}
}

ctl._aw_ctl {
  type hw
  card "${card_id}"
}

pcm._aw_dmix {
  type dmix
  ipc_key ${ipc_key}
  ipc_perm 0660
  slave {
    pcm "_aw_hw"
    channels 2
    rate ${anchor}
    format ${fmt}
    period_time 125000   # 125 ms periods
    buffer_time 500000   # 500 ms buffer
  }
}

pcm._aw_softvol {
  type softvol
  slave.pcm "_aw_dmix"
  control {
    name "SoftMaster"
    card "${card_id}"
  }
  min_dB -51.0
  max_dB 0.0
}

pcm.!default {
  type plug
  slave.pcm "_aw_softvol"
}

ctl.!default {
  type hw
  card "${card_id}"
}
EOF
}

write_policy_json() {
  local path="$1" hw="$2" card_id="$3" card_num="$4" dev_num="$5" anchor="$6" fmt="$7" usb="$8" soxr_req="$9" vid="${10:-}" pid="${11:-}"
  cat >"$path" <<EOF
{
  "hw": "$(json_escape "$hw")",
  "card_id": "$(json_escape "$card_id")",
  "card_num": ${card_num},
  "device_num": ${dev_num},
  "usb": ${usb},
  "vendor_id": "$(json_escape "${vid}")",
  "product_id": "$(json_escape "${pid}")",
  "anchor_hz": ${anchor},
  "format": "$(json_escape "$fmt")",
  "soxr_required": ${soxr_req},
  "updated": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
}

json_fingerprint() {
  # Print a short, comparable fingerprint string from the policy JSON
  local json="$1"
  awk -F'[:", ]+' '/"card_id"/{cid=$5} /"device_num"/{dev=$3} /"anchor_hz"/{anc=$3} /"format"/{fmt=$5} END{print cid":"dev":"anc":"fmt}' "$json" 2>/dev/null || true
}

main() {
  require_root
  ensure_state_dir

  local hw card_num dev_num card_id usb=0 vid pid anchor fmt soxr_req rates formats
  hw=$(probe_hw_from_repo)
  read -r card_num dev_num < <(card_dev_from_hw "$hw") || true
  [[ -n "$card_num" && -n "$dev_num" ]] || die "could not parse card/device from '$hw'"
  card_id=$(card_id_from_num "$card_num")
  [[ -n "$card_id" ]] || die "could not resolve card id for card $card_num"

  if is_usb_card "$card_num"; then
    usb=1
    read -r vid pid < <(usb_vidpid "$card_num" || true) || true
  else
    usb=0
    vid=""; pid=""
  fi

  read -r anchor fmt soxr_req < <(decide_anchor_and_format "$hw" "$card_num" "$dev_num" "$usb") || true
  [[ -n "$anchor" && -n "$fmt" ]] || die "could not decide anchor/format"

  # Build new JSON and compare
  local tmpjson
  tmpjson=$(mktemp)
  write_policy_json "$tmpjson" "$hw" "$card_id" "$card_num" "$dev_num" "$anchor" "$fmt" "$usb" "$soxr_req" "${vid:-}" "${pid:-}"
  local newfp oldfp
  newfp=$(json_fingerprint "$tmpjson")
  if [[ -f "$FPR_JSON" ]]; then oldfp=$(json_fingerprint "$FPR_JSON" || true); fi

  local changed=1
  if [[ -n "${oldfp:-}" && "$oldfp" == "$newfp" && -f "$ASOUND_CONF" ]]; then
    changed=0
  fi

  if [[ $changed -eq 1 ]]; then
    log "writing $ASOUND_CONF (anchor=${anchor}Hz, format=${fmt}, card=${card_id}:${dev_num})"
    render_asound_conf "$ASOUND_CONF" "$card_id" "$card_num" "$dev_num" "$anchor" "$fmt"
    install -m 0644 "$tmpjson" "$FPR_JSON"
  else
    # Still update JSON timestamp for visibility
    install -m 0644 "$tmpjson" "$FPR_JSON"
  fi
  rm -f "$tmpjson"

  configure_analog_controls "$card_num" "$usb"

  # Print concise JSON to stdout
  printf '{"anchor_hz":%s,"mode":"%s","hw":"%s","card_id":"%s","card_num":%s,"device_num":%s,"format":"%s","usb":%s,"soxr_required":%s}\n' \
    "$anchor" "$( [[ "$anchor" = 44100 ]] && echo 44100-anchored || echo 48000-anchored+soxr )" \
    "$(json_escape "$hw")" "$(json_escape "$card_id")" "$card_num" "$dev_num" "$(json_escape "$fmt")" "$usb" "$soxr_req"
}

main "$@"
