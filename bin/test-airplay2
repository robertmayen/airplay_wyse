#!/usr/bin/env bash
set -euo pipefail

# AirPlay 2 functional and diagnostic tool

ts() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
log() { echo "$(ts) [test-airplay2] $*"; }
fail() { log "ERROR: $*"; exit 1; }

SHOW_LOGS=0
SHOW_MDNS=0
SHOW_ALSA=0
STRICT=1
DRIFT_DUR=""
SHOW_PW=0

usage() {
  cat <<EOF
Usage: ./bin/test-airplay2 [--logs] [--mdns] [--alsa] [--pw] [--no-strict] [--drift <duration>]

Default runs strict functionality checks (nqptp, shairport, mDNS, ALSA listing).

  --logs       Show recent shairport/nqptp logs and last-health.json if present
  --mdns       Show detailed avahi-browse output for _airplay._tcp and _raop._tcp
  --alsa       Show ALSA cards and attempt basic listing
  --pw         Show PipeWire policy and current clock rate if present
  --no-strict  Do not exit non-zero on failures (report only)
  --drift D    Run a bounded drift sanity check while playing (e.g., 60s, 5m)
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --logs) SHOW_LOGS=1 ;;
      --mdns) SHOW_MDNS=1 ;;
      --alsa) SHOW_ALSA=1 ;;
      --no-strict) STRICT=0 ;;
      --pw) SHOW_PW=1 ;;
      --drift) shift; DRIFT_DUR="${1:-}" ;;
      -h|--help) usage; exit 0 ;;
      *) fail "unknown argument: $1" ;;
    esac
    shift || true
  done
}

duration_to_seconds() {
  local d="$1"
  if [[ -z "$d" ]]; then echo 0; return 0; fi
  if [[ "$d" =~ ^[0-9]+$ ]]; then echo "$d"; return 0; fi
  if [[ "$d" =~ ^([0-9]+)s$ ]]; then echo "${BASH_REMATCH[1]}"; return 0; fi
  if [[ "$d" =~ ^([0-9]+)m$ ]]; then echo $(( ${BASH_REMATCH[1]} * 60 )); return 0; fi
  echo "$d"
}

run_drift_check() {
  local duration="$1"
  [[ -n "$duration" ]] || return 0
  local secs
  secs=$(duration_to_seconds "$duration")
  [[ "$secs" =~ ^[0-9]+$ ]] || { log "invalid --drift duration '$duration'"; return 0; }
  log "Drift sanity check for ${secs}s (expect playback active)"
  local c_stuff=0 c_sync=0 c_resync=0 c_xrun=0 c_und=0 c_over=0 saw_lines=0
  local line lcl
  while IFS= read -r line; do
    lcl=$(printf '%s' "$line" | tr '[:upper:]' '[:lower:]')
    [[ "$lcl" == *"stuffing"* ]] && ((c_stuff++))
    [[ "$lcl" == *"sync error"* ]] && ((c_sync++))
    { [[ "$lcl" == *"resync"* ]] || [[ "$lcl" == *"flush"* ]]; } && ((c_resync++))
    [[ "$lcl" == *"underrun"* ]] && ((c_und++))
    [[ "$lcl" == *"overrun"* ]] && ((c_over++))
    [[ "$lcl" == *"xrun"* ]] && ((c_xrun++))
    ((saw_lines++))
  done < <(timeout "$secs" journalctl -f -u shairport-sync --no-pager -o short-iso 2>&1 || true)
  log "Drift summary: stuffing=$c_stuff sync_error=$c_sync resync/flush=$c_resync xruns=$c_xrun underrun=$c_und overrun=$c_over"
  if [[ $saw_lines -eq 0 ]]; then
    log "⚠ no shairport logs captured; ensure playback is active during drift check"
    return 0
  fi
  # Heuristics: minimal stuffing/sync_error/resync expected over short windows
  local threshold=$(( secs / 30 + 2 ))
  # Allow small counts, fail if egregious
  if (( c_resync > threshold || c_sync > threshold*2 )); then
    soft_or_fail "excessive resync/sync_error observed during drift check" false
  fi
}

soft_or_fail() {
  local msg="$1"; shift
  if ! "$@"; then
    if [[ $STRICT -eq 1 ]]; then
      fail "$msg"
    else
      log "⚠ $msg"
      return 1
    fi
  fi
}

test_nqptp() {
  log "Testing nqptp service..."
  soft_or_fail "nqptp service is not active" systemctl is-active --quiet nqptp.service
  soft_or_fail "nqptp service is not enabled" systemctl is-enabled --quiet nqptp.service
  log "✓ nqptp service looks good"
}

test_shairport_sync() {
  log "Testing shairport-sync..."
  soft_or_fail "shairport-sync binary not found" command -v shairport-sync >/dev/null 2>&1
  local version_output
  version_output=$(shairport-sync -V 2>&1 || true)
  if ! echo "$version_output" | grep -q "AirPlay2"; then
    soft_or_fail "shairport-sync does not report AirPlay 2 support" false
  fi
  soft_or_fail "shairport-sync service is not active" systemctl is-active --quiet shairport-sync.service
  log "✓ shairport-sync is active (version: $(echo "$version_output" | head -1))"
}

test_ptp_ports() {
  log "Checking NQPTP port ownership (UDP 319/320)..."
  local ok319=0 ok320=0
  if command -v ss >/dev/null 2>&1; then
    ss -u -lnp 2>/dev/null | grep -E ':(319|320)\s' | grep -q nqptp && ok319=1 || ok319=0
    ss -u -lnp 2>/dev/null | grep -E ':320\s' | grep -q nqptp && ok320=1 || ok320=0
  elif command -v lsof >/dev/null 2>&1; then
    lsof -nP -i UDP:319 2>/dev/null | grep -q nqptp && ok319=1 || ok319=0
    lsof -nP -i UDP:320 2>/dev/null | grep -q nqptp && ok320=1 || ok320=0
  else
    log "⚠ neither ss nor lsof present; skipping port ownership check"
    return 0
  fi
  soft_or_fail "nqptp should own UDP 319" bash -c "[[ $ok319 -eq 1 ]]"
  soft_or_fail "nqptp should own UDP 320" bash -c "[[ $ok320 -eq 1 ]]"
  if [[ $ok319 -eq 1 && $ok320 -eq 1 ]]; then
    log "✓ nqptp owns UDP 319/320"
  fi
}

test_avahi_advertisement() {
  log "Testing Avahi service advertisement..."
  if ! command -v avahi-browse >/dev/null 2>&1; then
    log "⚠ avahi-browse not available, skipping advertisement test"
    return 0
  fi
  local hostname browse_output ok=0
  hostname=$(hostname -s | tr '[:upper:]' '[:lower:]')
  browse_output=$(timeout 10 avahi-browse -rt _airplay._tcp 2>/dev/null || true)
  if [[ -n "$browse_output" ]] && echo "$browse_output" | grep -qi "$hostname"; then
    log "✓ AirPlay (_airplay._tcp) is advertised"
    ok=1
  fi
  if [[ $ok -eq 0 ]]; then
    browse_output=$(timeout 10 avahi-browse -rt _raop._tcp 2>/dev/null || true)
    if [[ -n "$browse_output" ]] && echo "$browse_output" | grep -qi "$hostname"; then
      log "✓ RAOP (_raop._tcp) is advertised"
      ok=1
    fi
  fi
  if [[ $ok -eq 0 ]]; then
    soft_or_fail "No AirPlay/RAOP service advertisement found" false
  fi
}

test_alsa_device() {
  log "Testing ALSA availability..."
  if ! command -v aplay >/dev/null 2>&1; then
    log "⚠ aplay not available, skipping ALSA test"
    return 0
  fi
  if ! aplay -l >/dev/null 2>&1; then
    soft_or_fail "No ALSA audio devices found" false
    return 0
  fi
  log "✓ ALSA audio devices are present"
  # Anchor mode and policy checks
  local policy_json="" anchor="" soxr_required=0
  for candidate in /var/lib/airplay_wyse/config.json /var/lib/airplay_wyse/alsa-policy.json; do
    if [[ -f "$candidate" ]]; then
      policy_json="$candidate"
      break
    fi
  done
  if [[ -n "$policy_json" ]]; then
    anchor=$(awk -F'[,:}]' '/"anchor_hz"/{for(i=1;i<=NF;i++) if ($i ~ /"anchor_hz"/) {val=$(i+1); gsub(/[^0-9]/, "", val); print val; exit}}' "$policy_json")
    local soxr_raw
    soxr_raw=$(awk -F'[,:}]' '/"requires_soxr"/{for(i=1;i<=NF;i++) if ($i ~ /"requires_soxr"/) {val=$(i+1); gsub(/[ \t\r\n\"]/, "", val); print val; exit}}' "$policy_json")
    case "$soxr_raw" in
      1|true|TRUE) soxr_required=1 ;;
      *) soxr_required=0 ;;
    esac
    if [[ -n "$anchor" ]]; then
      if [[ "$anchor" == "44100" ]]; then
        log "ALSA policy: anchor=44100 (AirPlay-native)"
      elif [[ "$anchor" == "48000" && $soxr_required -eq 1 ]]; then
        log "ALSA policy: anchor=48000 (+soxr)"
      else
        log "ALSA policy: anchor=${anchor}"
      fi
    else
      log "ALSA policy state present but anchor missing"
    fi
  fi
  if [[ -f /etc/asound.conf ]]; then
    local has_hw has_default has_ctl
    grep -qi 'pcm.airplay_wyse_hw' /etc/asound.conf && has_hw=OK || has_hw=NO
    if grep -qi 'pcm.!default' /etc/asound.conf && \
       grep -qi 'type[[:space:]]\+plug' /etc/asound.conf && \
       grep -qi 'slave.pcm[[:space:]]\+airplay_wyse_hw' /etc/asound.conf; then
      has_default=OK
    else
      has_default=NO
    fi
    grep -qi 'ctl.!default' /etc/asound.conf && has_ctl=OK || has_ctl=NO
    log "ALSA chain: hw=${has_hw} default_plug=${has_default} ctl=${has_ctl}"
    soft_or_fail "ALSA default chain is incomplete" bash -c "[[ '$has_hw' = OK && '$has_default' = OK ]]"
  else
    soft_or_fail "/etc/asound.conf is missing" false
  fi
}

show_logs() {
  echo "=== Recent Logs ==="
  journalctl -u shairport-sync -n 30 --no-pager 2>/dev/null || echo "No shairport logs available"
  journalctl -u nqptp -n 30 --no-pager 2>/dev/null || echo "No nqptp logs available"
  echo
  if [[ -f /var/lib/airplay_wyse/last-health.json ]]; then
    echo "=== Last Health ==="
    if command -v jq >/dev/null 2>&1; then
      jq . /var/lib/airplay_wyse/last-health.json 2>/dev/null || cat /var/lib/airplay_wyse/last-health.json
    else
      cat /var/lib/airplay_wyse/last-health.json
    fi
  fi
}

show_mdns() {
  echo "=== mDNS Details ==="
  if command -v avahi-browse >/dev/null 2>&1; then
    echo "-- _airplay._tcp --"
    timeout 10 avahi-browse -rt _airplay._tcp 2>/dev/null || true
    echo
    echo "-- _raop._tcp --"
    timeout 10 avahi-browse -rt _raop._tcp 2>/dev/null || true
  else
    echo "avahi-browse not installed"
  fi
}

show_alsa() {
  echo "=== ALSA Devices ==="
  if command -v aplay >/dev/null 2>&1; then
    aplay -l 2>/dev/null || true
  else
    echo "aplay not installed"
  fi
}

check_policy_and_soxr() {
  # Confirm Shairport uses ALSA default device and soxr is present when required
  local conf_dev soxr_built anchor soxr_required=0
  conf_dev=$(awk 'BEGIN{IGNORECASE=1}
    /^alsa[[:space:]]*=/{insec=1}
    insec && /output_device[[:space:]]*=/ {match($0,/"[^"]+"/); if(RSTART>0){v=substr($0,RSTART+1,RLENGTH-2); print v; exit}}
    insec && /^};/ {insec=0}
  ' /etc/shairport-sync.conf 2>/dev/null || true)
  if [[ -n "$conf_dev" ]]; then
    soft_or_fail "shairport output_device should be 'default' (got '$conf_dev')" bash -c "[[ '$conf_dev' == 'default' ]]"
  fi
  for candidate in /var/lib/airplay_wyse/config.json /var/lib/airplay_wyse/alsa-policy.json; do
    if [[ -f "$candidate" ]]; then
      anchor=$(awk -F'[,:}]' '/"anchor_hz"/{for(i=1;i<=NF;i++) if ($i ~ /"anchor_hz"/) {val=$(i+1); gsub(/[^0-9]/, "", val); print val; exit}}' "$candidate")
      local soxr_raw
      soxr_raw=$(awk -F'[,:}]' '/"requires_soxr"/{for(i=1;i<=NF;i++) if ($i ~ /"requires_soxr"/) {val=$(i+1); gsub(/[ \t\r\n\"]/, "", val); print val; exit}}' "$candidate")
      if [[ -n "$soxr_raw" ]]; then
        case "$soxr_raw" in
          1|true|TRUE) soxr_required=1 ;;
          *) soxr_required=0 ;;
        esac
      fi
      break
    fi
  done
  if shairport-sync -V 2>&1 | grep -q soxr; then soxr_built=1; else soxr_built=0; fi
  if [[ "${soxr_required:-0}" -eq 1 ]]; then
    soft_or_fail "anchor=48000 requires libsoxr support in shairport-sync" bash -c "[[ ${soxr_built} -eq 1 ]]"
  fi
}

main() {
  parse_args "$@"
  log "Starting AirPlay 2 checks..."
  test_nqptp
  test_shairport_sync
  test_avahi_advertisement
  # Identity checks via verify-airplay-identity: asserts non-empty AirPlay2 pk and non-zero RAOP deviceid.
  if [[ -x "$(dirname "$0")/verify-airplay-identity" ]]; then
    if ! "$(dirname "$0")/verify-airplay-identity"; then
      log "Suggestion: sudo /opt/airplay_wyse/bin/identity-ensure --force && sudo systemctl restart shairport-sync"
      if [[ $STRICT -eq 1 ]]; then exit 1; fi
    fi
  fi
  test_alsa_device
  test_ptp_ports
  check_policy_and_soxr
  if [[ $SHOW_PW -eq 1 ]]; then
    echo "=== PipeWire Policy ==="
    if [[ -f /etc/pipewire/pipewire.conf.d/90-airplay_wyse.conf ]]; then
      echo "/etc/pipewire/pipewire.conf.d/90-airplay_wyse.conf:"; sed -n '1,120p' /etc/pipewire/pipewire.conf.d/90-airplay_wyse.conf 2>/dev/null || true
    else
      echo "No AirPlay Wyse PipeWire drop-in present"
    fi
    if command -v pw-dump >/dev/null 2>&1; then
      local rate
      rate=$(pw-dump 2>/dev/null | awk -F'[,: ]+' '/"clock\.rate"/{print $3; exit}' | tr -dc '0-9')
      if [[ -n "$rate" ]]; then
        log "PipeWire current clock.rate=${rate}"
      fi
    fi
  fi
  [[ $SHOW_LOGS -eq 1 ]] && show_logs || true
  [[ $SHOW_MDNS -eq 1 ]] && show_mdns || true
  [[ $SHOW_ALSA -eq 1 ]] && show_alsa || true
  [[ -n "${DRIFT_DUR:-}" ]] && run_drift_check "$DRIFT_DUR" || true
  log "✓ Checks complete"
  log "Device should be discoverable as an AirPlay receiver"
}

main "$@"
