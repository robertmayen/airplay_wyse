#!/usr/bin/env bash
set -euo pipefail

# alsa-probe: resolve an ALSA output device string hw:<card>,<device>
# Preference: inventory overrides -> USB DACs -> first available playback
# Exits non-zero if no playable device can be determined.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

host_short() { hostname -s 2>/dev/null || hostname; }
INV="$REPO_DIR/inventory/hosts/$(host_short).yml"

# Minimal YAML reader for our needs
yaml_get() {
  local key="$1" val=""
  [[ -f "$INV" ]] || { echo ""; return 0; }

  if [[ "$key" == alsa.* ]]; then
    local subkey="${key#alsa.}"
    val=$(awk -v want="$subkey" '
      function strip(s) { gsub(/^[ \t]+|[ \t]+$/, "", s); return s }
      function unq(s) {
        gsub(/^\"|\"$/, "", s)   # remove surrounding "
        q = sprintf("%c", 39)
        gsub("^" q "|" q "$", "", s)  # remove surrounding single quotes
        return s
      }
      BEGIN { IGNORECASE=1; insec=0; sec_indent=-1 }
      {
        line=$0
        sub(/[ \t]*#.*/, "", line)
        if (line ~ /^[ \t]*$/) next
      }
      match(line, /^([ \t]*)alsa:[ \t]*$/, m) { insec=1; sec_indent=length(m[1]); next }
      {
        if (insec) {
          match(line, /^([ \t]*)/, mi)
          indent=length(mi[1])
          if (indent <= sec_indent) { insec=0 }
        }
      }
      insec && match(line, /^[ \t]*([A-Za-z0-9_]+)[ \t]*:[ \t]*(.*)$/, kv) {
        k=kv[1]; v=strip(kv[2]); v=unq(v)
        if (tolower(k) == tolower(want)) { print v; exit }
      }
    ' "$INV" ) || true
    if [[ -n "$val" ]]; then echo "$val"; return 0; fi
  fi

  # Fallback: flat key on a single line
  val=$(grep -E "^${key}:[[:space:]]" "$INV" 2>/dev/null | sed -E "s/^${key}:[[:space:]]*//" | sed -E 's/[[:space:]]+#.*$//' | tr -d '"') || true
  echo "${val}"
}

# First playback device index for a given card number
first_playback_dev() {
  local c="$1" d
  for d in /proc/asound/card"$c"/pcm*p; do
    [[ -e "$d" ]] || continue
    d=$(basename "$d")
    echo "${d#pcm}" | tr -d 'p'
    return 0
  done
  return 1
}

normalize_hex() { printf '%s\n' "$1" | tr 'A-F' 'a-f'; }

# 1) Explicit override
exp=$(yaml_get 'alsa.device' || true)
if [[ -n "${exp:-}" ]]; then
  echo "$exp"
  exit 0
fi

# 2) VID:PID preferred match
vid=$(yaml_get 'alsa.vendor_id' || true)
pid=$(yaml_get 'alsa.product_id' || true)
devnum=$(yaml_get 'alsa.device_num' || true)
devnum=${devnum:-0}
vid_l=$(normalize_hex "${vid}")
pid_l=$(normalize_hex "${pid}")

if [[ -n "${vid_l:-}" && -n "${pid_l:-}" ]]; then
  for cdir in /sys/class/sound/card*; do
    [[ -d "$cdir" ]] || continue
    devdir=$(readlink -f "$cdir/device" 2>/dev/null || true)
    if [[ -n "$devdir" && -f "$devdir/idVendor" && -f "$devdir/idProduct" ]]; then
      V=$(normalize_hex "0x$(cat "$devdir/idVendor" 2>/dev/null || echo)")
      P=$(normalize_hex "0x$(cat "$devdir/idProduct" 2>/dev/null || echo)")
      if [[ "$V" == "$vid_l" && "$P" == "$pid_l" ]]; then
        card=$(basename "$cdir"); card=${card#card}
        if p=$(first_playback_dev "$card"); then
          echo "hw:${card},${devnum:-$p}"
          exit 0
        fi
      fi
    fi
  done
fi

# 3) Any USB card -> prefer raw hw:
for cdir in /sys/class/sound/card*; do
  [[ -d "$cdir" ]] || continue
  devdir=$(readlink -f "$cdir/device" 2>/dev/null || true)
  if [[ -n "$devdir" && -f "$devdir/idVendor" && -f "$devdir/idProduct" ]]; then
    card=$(basename "$cdir"); card=${card#card}
    if p=$(first_playback_dev "$card"); then
      echo "hw:${card},${devnum:-$p}"
      exit 0
    fi
  fi
done

# 4) Fallback: first playback on any non-USB card -> plughw:
for cdir in /sys/class/sound/card*; do
  [[ -d "$cdir" ]] || continue
  devdir=$(readlink -f "$cdir/device" 2>/dev/null || true)
  if [[ -z "$devdir" || ! ( -f "$devdir/idVendor" && -f "$devdir/idProduct" ) ]]; then
    card=$(basename "$cdir"); card=${card#card}
    if p=$(first_playback_dev "$card"); then
      echo "plughw:${card},${devnum:-$p}"
      exit 0
    fi
  fi
done

exit 1
