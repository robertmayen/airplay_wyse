#!/usr/bin/env bash
set -euo pipefail

# preflight-alsa: Validate configured ALSA PCM before shairport starts.
# - For hw:<c>,<d> require /proc/.../hw_params rate: 44100 while opened.
# - For named/plug PCMs, require that opening at -r 44100 succeeds quickly.

CONF_DIR="/etc"
CONF_MAIN="/etc/shairport-sync.conf"
CONF_D_DIR="/etc/shairport-sync.conf.d"
REPO_DIR="/opt/airplay_wyse"

ts() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
err() { echo "$(ts) [preflight-alsa] $*" >&2; }

read_device_from_file() {
  local file="$1"
  [ -f "$file" ] || return 1
  awk 'BEGIN{IGNORECASE=1; insec=0}
    /^[[:space:]]*\/\//{next} /^[[:space:]]*#/ {next}
    /alsa[[:space:]]*=/{insec=1}
    insec && /output_device[[:space:]]*=/ {match($0,/"[^"]+"/); if(RSTART>0){v=substr($0,RSTART+1,RLENGTH-2); print v; exit}}
    insec && /^};/ {insec=0}
  ' "$file" 2>/dev/null || true
}

read_effective_device() {
  # Mimic shairport’s conf layering: main file then conf.d/*.conf, last one wins
  local dev=""
  dev="$(read_device_from_file "$CONF_MAIN" || true)"
  if [ -d "$CONF_D_DIR" ]; then
    # Process files in lexical order; later overrides earlier
    local f
    for f in "$CONF_D_DIR"/*.conf; do
      [ -f "$f" ] || continue
      local d
      d="$(read_device_from_file "$f" || true)"
      if [ -n "$d" ]; then dev="$d"; fi
    done
  fi
  [ -n "$dev" ] && echo "$dev"
}

open_quick() {
  local dev="$1"
  timeout 0.25 aplay -D "$dev" -r 44100 -f S16_LE -c 2 -t raw /dev/zero -q >/dev/null 2>&1 || return 1
  return 0
}

named_pcm_loaded() {
  local dev="$1"
  command -v aplay >/dev/null 2>&1 || return 1
  aplay -L 2>/dev/null | awk -v d="$dev" 'BEGIN{ok=0} $0==d{ok=1} END{exit ok?0:1}'
}

hw_params_path() {
  local dev="$1" card d base
  [[ "$dev" =~ ^hw:([0-9]+),([0-9]+)$ ]] || return 1
  card="${BASH_REMATCH[1]}"; d="${BASH_REMATCH[2]}"; base="/proc/asound/card${card}/pcm${d}p"
  for sub in "$base"/sub*; do
    [[ -f "$sub/status" ]] || continue
    if grep -q '^state: *RUNNING' "$sub/status" 2>/dev/null; then
      echo "$sub/hw_params"; return 0
    fi
  done
  # fallback to any
  for sub in "$base"/sub*/hw_params; do [[ -f "$sub" ]] && { echo "$sub"; return 0; }; done
  return 1
}

main() {
  local dev hwp rate
  dev="$(read_effective_device || true)"
  if [[ -z "$dev" ]]; then
    err "shairport preflight: sink not 44.1k (no device) → see docs/OPERATIONS.md#Clocking"
    exit 1
  fi
  if [[ "$dev" == hw:* ]]; then
    # Require hardware 44.1k
    open_quick "$dev" || { err "shairport preflight: sink not 44.1k (open failed) → run /opt/airplay_wyse/bin/apply to reselect or regenerate wrapper"; exit 2; }
    hwp="$(hw_params_path "$dev" || true)"
    if [[ -n "$hwp" && -f "$hwp" ]]; then
      rate=$(awk '/^rate:/{print $2}' "$hwp" 2>/dev/null || true)
      if [[ "$rate" != "44100" ]]; then
        err "shairport preflight: sink not 44.1k (got ${rate:-unknown}) → see docs/OPERATIONS.md#clocking"
        exit 3
      fi
    fi
    exit 0
  fi
  # Named/plug PCMs: accept boundary open at 44.1k
  if ! named_pcm_loaded "$dev"; then
    err "shairport preflight: named PCM '$dev' not loaded by ALSA → ensure /etc/asound.conf includes /etc/asound.d/airplay_wyse.conf"
    exit 5
  fi
  open_quick "$dev" || { err "shairport preflight: sink not 44.1k (plug boundary failed) → run /opt/airplay_wyse/bin/apply to regenerate wrapper"; exit 4; }
  exit 0
}

main "$@"
