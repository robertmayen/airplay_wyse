#!/usr/bin/env bash
set -euo pipefail

STATE_DIR="/var/lib/airplay_wyse"
LAST_UPDATE_FILE="$STATE_DIR/last-update.txt"
REPO_DIR="/opt/airplay_wyse"

log() { printf '%s %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$*"; }
SUPPRESS_TRAP_LOG=0

write_last_update() {
  local ts target rc
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  target=${1:-}
  rc=${2:-1}
  mkdir -p "$STATE_DIR" 2>/dev/null || true
  {
    echo "ts=$ts"
    echo "target=$target"
    echo "rc=$rc"
  } >"$LAST_UPDATE_FILE" 2>/dev/null || true
}

sync_systemd_units() { :; }

# Bootstrap logic removed in minimal path; wrapper/sudoers are a prerequisite.

yaml_get_target_tag() {
  local file=$1
  # Extract value, trimming whitespace and wrapping quotes (single or double)
  # Example: target_tag: "v1.2.3" -> v1.2.3
  if [[ -f "$file" ]]; then
    grep -E '^[[:space:]]*target_tag[[:space:]]*:' "$file" | \
      sed -E 's/^[[:space:]]*target_tag[[:space:]]*:[[:space:]]*//; s/^["'"'']|["'"'']$//g' | \
      head -n1
  fi
}

highest_semver_tag() {
  git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | \
    grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | \
    sort -V | tail -n1
}

current_commit_matches_tag() {
  local tag=$1
  local head tgt
  head=$(git rev-parse HEAD)
  tgt=$(git rev-list -n1 "$tag")
  [[ "$head" == "$tgt" ]]
}

short_host() { hostname -s 2>/dev/null || hostname; }

main() {
  local rc=1 target_tag=""

  # Root-run model: invoked by reconcile.service as root

  cd "$REPO_DIR"
  log "Updater starting in $PWD"

  # Fetch tags with pruning to ensure devices drop stale/moved tags
  log "Running: git fetch --tags --force --prune --prune-tags origin"
  set +e
  GIT_TERMINAL_PROMPT=0 git fetch --tags --force --prune --prune-tags origin
  fetch_rc=$?
  set -e
  if [[ $fetch_rc -ne 0 ]]; then
    # Fallback: if origin is SSH (e.g., git@github.com:org/repo.git), try HTTPS to avoid host key prompts
    origin_url=$(git remote get-url origin 2>/dev/null || echo "")
    https_url=""
    if echo "$origin_url" | grep -Eq '^git@[^:]+:'; then
      host=$(echo "$origin_url" | sed -E 's/^git@([^:]+):.*/\1/')
      path=$(echo "$origin_url" | sed -E 's/^git@[^:]+:(.*)$/\1/')
      https_url="https://$host/$path"
    elif echo "$origin_url" | grep -Eq '^ssh://'; then
      # Convert ssh://host/path to https://host/path
      https_url=$(echo "$origin_url" | sed -E 's#^ssh://#https://#')
    fi
    if [[ -n "$https_url" ]]; then
      log "SSH fetch failed (rc=$fetch_rc); retrying via $https_url"
      set +e
      GIT_TERMINAL_PROMPT=0 git fetch "$https_url" --tags --force --prune --prune-tags
      fetch_rc=$?
      set -e
    fi
    if [[ $fetch_rc -ne 0 ]]; then
      log "Updater failed rc=$fetch_rc"
      write_last_update "" $fetch_rc
      exit $fetch_rc
    fi
  fi

  # Prefer per-host inventory target_tag
  local inv="$REPO_DIR/inventory/hosts/$(short_host).yml"
  if [[ -f "$inv" ]]; then
    target_tag=$(yaml_get_target_tag "$inv" || true)
  fi
  if [[ -z "${target_tag:-}" ]]; then
    target_tag=$(highest_semver_tag || true)
  fi
  if [[ -z "${target_tag:-}" ]]; then
    log "No target tag determined (no target_tag and no SemVer tags)"
    write_last_update "" 1
    exit 1
  fi
  log "Target tag: $target_tag"

  # Ensure selected tag exists after fetch; if not, emit a single structured error and exit non-zero
  if ! git show-ref --verify --quiet "refs/tags/$target_tag"; then
    # Structured single-line error suitable for journald parsing
    log "event=update_error kind=tag_mismatch target_tag=$target_tag reason=missing_tag_after_fetch"
    write_last_update "$target_tag" 1
    SUPPRESS_TRAP_LOG=1
    exit 1
  fi

  # Optional GPG verification (disabled by default). Enable with AIRPLAY_VERIFY_TAGS=1
  # or by setting `verify_gpg: true` in the host inventory file.
  verify_flag="${AIRPLAY_VERIFY_TAGS:-}"
  if [[ -z "$verify_flag" && -f "$inv" ]]; then
    if grep -Eiq '^verify_gpg:\s*(true|yes|1)\b' "$inv"; then
      verify_flag=1
    else
      verify_flag=0
    fi
  fi
  verify_flag=${verify_flag:-0}
  if [[ "$verify_flag" == "1" ]]; then
    if ! git verify-tag "$target_tag"; then
      log "git verify-tag failed for $target_tag"
      write_last_update "$target_tag" 1
      exit 1
    fi
  else
    log "GPG tag verification disabled (using SSH/Git SHA workflows)"
  fi

  if current_commit_matches_tag "$target_tag"; then
    log "Already at $target_tag"
  else
    log "Checking out tags/$target_tag"
    git checkout -f "tags/$target_tag"
  fi

  # Ensure critical scripts are executable (defense-in-depth for filemode issues)
  for f in \
    "$REPO_DIR/bin/converge" \
    "$REPO_DIR/bin/reconcile" \
    "$REPO_DIR/bin/update" \
    "$REPO_DIR/bin/diag" \
    "$REPO_DIR/bin/health" \
    "$REPO_DIR/bin/alsa-probe" \
    "$REPO_DIR/bin/test-airplay2"; do
    [[ -f "$f" ]] && chmod +x "$f" 2>/dev/null || true
  done

  # Sync systemd units if repo versions changed (GitOps for units)
  sync_systemd_units

  # Package installs and unit sync handled by converge/reconcile.

  write_last_update "$target_tag" 0
  log "Updater completed"
}

trap 'rc=$?; if [[ $rc -ne 0 && ${SUPPRESS_TRAP_LOG:-0} -ne 1 ]]; then log "Updater failed rc=$rc"; fi; exit $rc' EXIT
main "$@"
