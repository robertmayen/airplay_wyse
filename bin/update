#!/usr/bin/env bash
set -euo pipefail

STATE_DIR="/var/lib/airplay_wyse"
LAST_UPDATE_FILE="$STATE_DIR/last-update.txt"
REPO_DIR="/opt/airplay_wyse"

log() { printf '%s %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$*"; }

write_last_update() {
  local ts target rc
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  target=${1:-}
  rc=${2:-1}
  mkdir -p "$STATE_DIR" 2>/dev/null || true
  {
    echo "ts=$ts"
    echo "target=$target"
    echo "rc=$rc"
  } >"$LAST_UPDATE_FILE" 2>/dev/null || true
}

# Enqueue a privileged command for the broker to execute
enqueue_cmd() {
  local line="$*"; local ts rand f
  ts=$(date +%s)
  rand=$(od -An -N2 -tx2 /dev/urandom | tr -d ' \n')
  mkdir -p /run/airplay/queue 2>/dev/null || true
  f="/run/airplay/queue/${ts}.${rand}.cmd"
  printf '%s\n' "$line" >"$f"
}

# If repo units differ from system copies, update them via broker (GitOps for units)
sync_systemd_units() {
  local changed=0
  # Bootstrap: runtime drop-in to expand broker's writable paths so it can later write /etc units
  local dropdir="/run/systemd/system/converge-broker.service.d"
  local dropfile="$dropdir/10-apt-and-units.conf"
  # Create drop-in dir and write override via broker
  local ts rand cmdf inf
  ts=$(date +%s); rand=$(od -An -N2 -tx2 /dev/urandom | tr -d ' \n')
  echo "/usr/bin/install -d -m 0755 $dropdir" >"/run/airplay/queue/${ts}.${rand}.cmd"
  ts=$(date +%s); rand=$(od -An -N2 -tx2 /dev/urandom | tr -d ' \n')
  cmdf="/run/airplay/queue/${ts}.${rand}.cmd"; inf="/run/airplay/queue/${ts}.${rand}.in"
  cat >"$inf" <<'OVR'
[Service]
# allow apt caches and temp locations + units directory writes
ReadWritePaths=/var/cache/apt /var/lib/apt /var/lib/dpkg /var/tmp /tmp /etc/apt/preferences.d /var/log/apt /var/log/dpkg /etc/systemd/system
OVR
  echo "/usr/bin/tee $dropfile" >"$cmdf"
  changed=1

  for src in "$REPO_DIR"/systemd/*.service "$REPO_DIR"/systemd/*.path; do
    [[ -f "$src" ]] || continue
    local base dest
    base=$(basename "$src")
    dest="/etc/systemd/system/$base"
    if [[ ! -f "$dest" ]] || ! cmp -s "$src" "$dest"; then
      # Use broker tee with payload to write root-owned unit file
      local ts rand cmdf inf
      ts=$(date +%s); rand=$(od -An -N2 -tx2 /dev/urandom | tr -d ' \n')
      cmdf="/run/airplay/queue/${ts}.${rand}.cmd"
      inf="/run/airplay/queue/${ts}.${rand}.in"
      echo "/usr/bin/tee $dest" >"$cmdf"
      cp "$src" "$inf"
      changed=1
    fi
  done
  if [[ $changed -eq 1 ]]; then
    enqueue_cmd /usr/bin/systemctl daemon-reload
    # Restart the path unit so it picks up any changes to watcher configs
    enqueue_cmd /usr/bin/systemctl restart converge-broker.path
  fi
}

yaml_get_target_tag() {
  local file=$1
  awk -F: '/^target_tag\s*:/ {val=$2; sub(/^[[:space:]]+/,"",val); sub(/[[:space:]]+$/,"",val); gsub(/^"|"$/,"",val); gsub(/^\'"'"'|\'"'"'$/,"",val); print val; exit}' "$file" 2>/dev/null || true
}

highest_semver_tag() {
  git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | \
    grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | \
    sort -V | tail -n1
}

current_commit_matches_tag() {
  local tag=$1
  local head tgt
  head=$(git rev-parse HEAD)
  tgt=$(git rev-list -n1 "$tag")
  [[ "$head" == "$tgt" ]]
}

short_host() { hostname -s 2>/dev/null || hostname; }

main() {
  local rc=1 target_tag=""

  # Ensure correct user
  if [[ "$(id -un)" != "airplay" ]]; then
    echo "This script must run as user 'airplay'" >&2
    write_last_update "" 1
    exit 1
  fi

  cd "$REPO_DIR"
  log "Updater starting in $PWD"

  log "Fetching tags from origin"
  git fetch --tags origin

  # Prefer per-host inventory target_tag
  local inv="$REPO_DIR/inventory/hosts/$(short_host).yml"
  if [[ -f "$inv" ]]; then
    target_tag=$(yaml_get_target_tag "$inv" || true)
  fi
  if [[ -z "${target_tag:-}" ]]; then
    target_tag=$(highest_semver_tag || true)
  fi
  if [[ -z "${target_tag:-}" ]]; then
    log "No target tag determined (no target_tag and no SemVer tags)"
    write_last_update "" 1
    exit 1
  fi
  log "Target tag: $target_tag"

  # Optional GPG verification (disabled by default). Enable with AIRPLAY_VERIFY_TAGS=1
  # or by setting `verify_gpg: true` in the host inventory file.
  verify_flag="${AIRPLAY_VERIFY_TAGS:-}"
  if [[ -z "$verify_flag" && -f "$inv" ]]; then
    if grep -Eiq '^verify_gpg:\s*(true|yes|1)\b' "$inv"; then
      verify_flag=1
    else
      verify_flag=0
    fi
  fi
  verify_flag=${verify_flag:-0}
  if [[ "$verify_flag" == "1" ]]; then
    if ! git verify-tag "$target_tag"; then
      log "git verify-tag failed for $target_tag"
      write_last_update "$target_tag" 1
      exit 1
    fi
  else
    log "GPG tag verification disabled (using SSH/Git SHA workflows)"
  fi

  if current_commit_matches_tag "$target_tag"; then
    log "Already at $target_tag"
  else
    log "Checking out tags/$target_tag"
    git checkout -f "tags/$target_tag"
  fi

  # Ensure critical scripts are executable (defense-in-depth for filemode issues)
  for f in \
    "$REPO_DIR/bin/converge" \
    "$REPO_DIR/bin/converge-broker" \
    "$REPO_DIR/bin/preflight" \
    "$REPO_DIR/bin/update" \
    "$REPO_DIR/bin/diag" \
    "$REPO_DIR/bin/health" \
    "$REPO_DIR/bin/rollback" \
    "$REPO_DIR/pkg/install.sh"; do
    [[ -f "$f" ]] && chmod +x "$f" 2>/dev/null || true
  done

  # Sync systemd units if repo versions changed (GitOps for units)
  sync_systemd_units

  # Emit trigger for converge via path unit (no direct systemctl here)
  install -d -m 2775 -o root -g airplay /run/airplay || true
  : > /run/airplay/update.trigger

  write_last_update "$target_tag" 0
  log "Updater completed (triggered converge)"
}

trap 'rc=$?; if [[ $rc -ne 0 ]]; then log "Updater failed rc=$rc"; fi; exit $rc' EXIT
main "$@"
