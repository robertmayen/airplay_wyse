#!/usr/bin/env bash
set -euo pipefail

# verify-airplay-identity: developer convenience script and readiness check
# - Dumps local _airplay._tcp and _raop._tcp TXT
# - Fails if pk missing, AP2 deviceid is zero, or _raop instance prefix is zero
# - Additionally, when an identity reset was detected (instance.json mtime changed),
#   asserts that the current pk differs from the previously cached pk.
# - Prints one-line summary: <host> pk=<first8> deviceid=<MAC> iface=<iface>

STATE_DIR="/var/lib/airplay_wyse"
VERIFY_FILE="$STATE_DIR/verify.json"
INSTANCE_FILE="$STATE_DIR/instance.json"

host_short() { hostname -s 2>/dev/null || hostname; }

find_iface() {
  local conf="/etc/shairport-sync.conf" iface
  iface=$(awk 'BEGIN{IGNORECASE=1} /interface[[:space:]]*=/ {match($0, /=[[:space:]]*"[^"]+"/); if (RSTART>0) {v=substr($0, RSTART+2, RLENGTH-2); gsub(/^[ \t\"]+|[ \t\"]+$/, "", v); print v; exit}}' "$conf" 2>/dev/null || true)
  if [[ -n "$iface" ]]; then echo "$iface"; return 0; fi
  if command -v ip >/dev/null 2>&1; then
    ip route 2>/dev/null | awk '/^default/ {print $5; exit}'
  fi
}

avahi_dump() {
  local type="$1"
  timeout 8 avahi-browse -rt "$type" 2>/dev/null || true
}

extract_overrides_or_dump() {
  local type="$1"
  if [[ -n "${AP2_TXT_OVERRIDE:-}" && "$type" == "_airplay._tcp" ]]; then
    cat "$AP2_TXT_OVERRIDE" 2>/dev/null || true; return 0
  fi
  if [[ -n "${RAOP_TXT_OVERRIDE:-}" && "$type" == "_raop._tcp" ]]; then
    cat "$RAOP_TXT_OVERRIDE" 2>/dev/null || true; return 0
  fi
  avahi_dump "$type"
}

hwaddr_from_conf() {
  local conf="/etc/shairport-sync.conf"
  awk 'BEGIN{IGNORECASE=1} /hardware_address[[:space:]]*=/ {match($0, /=[[:space:]]*"[^"]+"/); if (RSTART>0) {v=substr($0, RSTART+2, RLENGTH-2); gsub(/^[ \t\"]+|[ \t\"]+$/, "", v); print v; exit}}' "$conf" 2>/dev/null || true
}

raop_prefix_from_dump() {
  extract_overrides_or_dump _raop._tcp | awk 'tolower($0) ~ /_raop\._tcp/ { for(i=1;i<=NF;i++) if ($i ~ /@/) { split($i,a,"@"); print a[1]; exit } }' | tr -d '\r' | head -n1
}

colonize_mac() { echo "$1" | sed -E 's/([0-9A-Fa-f]{2})/\1:/g; s/:$//' | tr '[:upper:]' '[:lower:]'; }

select_ap2_by_deviceid() {
  # args: expected_deviceid -> prints PK and DEVICEID (mawk-safe)
  local want="$1" dump pk di
  dump=$(extract_overrides_or_dump _airplay._tcp)
  awk -v want="$want" '
    BEGIN{inrec=0; di=""; pk=""; want_l=want; for(i=1;i<=length(want_l);i++){c=substr(want_l,i,1); want_l2=want_l2 (c>="A"&&c<="Z"?tolower(c):c)}; want_l=want_l2}
    # normalize tolower function portable
    function tolow(s,    i,c,t){t=""; for(i=1;i<=length(s);i++){c=substr(s,i,1); t=t ((c>="A"&&c<="Z")?tolower(c):c)}; return t}
    /^=/ {
      if (di!="" && tolow(di)==want_l) { printf("PK=%s\nDEVICEID=%s\n", pk, di); exit }
      di=""; pk=""; inrec=1; next
    }
    /TXT records:/ { inrec=1; next }
    inrec && /deviceid=/ {
      line=$0; line_l=tolow(line)
      pos=index(line_l, "deviceid=")
      if (pos>0) { di=substr(line, pos+9, 17) }
    }
    inrec && /pk=/ {
      line=$0; pos=index(line, "pk=")
      if (pos>0) {
        s=substr(line, pos+3)
        # strip non-hex
        gsub(/[^0-9A-Fa-f]/, "", s)
        pk=s
      }
    }
    END{ if (di!="" && tolow(di)==want_l) printf("PK=%s\nDEVICEID=%s\n", pk, di) }
  ' <<< "$dump"
}

usage() {
  cat <<EOF
Usage: $(basename "$0") [--wait SECS] [--from-files AP2_TXT RAOP_TXT]
Checks that _airplay._tcp TXT contains pk (hex) and deviceid (non-zero), and _raop._tcp matches.
EOF
}

stat_mtime() {
  # Portable-ish mtime extractor: Linux (stat -c %Y) and BSD/macOS (stat -f %m)
  local path="$1"; [[ -e "$path" ]] || { echo ""; return 0; }
  if stat -c %Y "$path" >/dev/null 2>&1; then
    stat -c %Y "$path" 2>/dev/null || true
  elif stat -f %m "$path" >/dev/null 2>&1; then
    stat -f %m "$path" 2>/dev/null || true
  else
    echo "" # Unknown platform; skip mtime-based checks
  fi
}

read_verify_json() {
  local field="$1"
  if command -v jq >/dev/null 2>&1; then
    jq -r ".${field} // empty" "$VERIFY_FILE" 2>/dev/null || true
  else
    awk -F'"' -v k="$field" '$2==k{print $4}' "$VERIFY_FILE" 2>/dev/null || true
  fi
}

write_verify_json() {
  local host="$1" pk="$2" dev="$3" inst_mtime="$4"
  local out="$VERIFY_FILE" dir_ok=0
  # Prefer system cache (/var/lib) when writable; otherwise fall back to user cache.
  # Do not fail the verification if caching is not possible.
  (
    set +e
    install -d -m 0755 "$STATE_DIR" 2>/dev/null
    test -w "$STATE_DIR" 2>/dev/null
    dir_ok=$?
    if [ $dir_ok -ne 0 ]; then
      local ucache
      ucache="${XDG_CACHE_HOME:-$HOME/.cache}/airplay_wyse"
      mkdir -p "$ucache" 2>/dev/null
      out="$ucache/verify.json"
    fi
    cat >"$out" <<EOF
{
  "host": "${host}",
  "last_pk": "${pk}",
  "last_deviceid": "${dev}",
  "instance_mtime": "${inst_mtime}",
  "last_checked": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
  ) || true
}

main() {
  local h iface a_txt r_txt pk deviceid raop_prefix rc=0 wait_secs=0 from_ap2="" from_raop=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --wait) shift; wait_secs="${1:-0}" ;;
      --from-files) shift; from_ap2="${1:-}"; shift; from_raop="${1:-}" ;;
      -h|--help) usage; exit 0 ;;
      *) echo "unknown arg: $1" >&2; exit 2 ;;
    esac; shift || true
  done
  if [[ -n "$from_ap2" && -n "$from_raop" ]]; then
    AP2_TXT_OVERRIDE="$from_ap2" RAOP_TXT_OVERRIDE="$from_raop" export AP2_TXT_OVERRIDE RAOP_TXT_OVERRIDE
  fi
  h="$(host_short)"
  iface="$(find_iface || true)"
  if [[ -z "${AP2_TXT_OVERRIDE:-}" && -z "${RAOP_TXT_OVERRIDE:-}" ]] && ! command -v avahi-browse >/dev/null 2>&1; then
    echo "avahi-browse not available" >&2
    exit 2
  fi
  # Optional wait for Avahi TXT and nqptp active
  if command -v systemctl >/dev/null 2>&1; then
    if ! systemctl is-active --quiet nqptp.service; then
      echo "ERROR: nqptp inactive" >&2
      exit 3
    fi
  fi
  # Optional wait for Avahi TXT
  local attempts=0 max_attempts
  max_attempts=$(( wait_secs>0 ? wait_secs : 1 ))
  while :; do
    raop_prefix=$(raop_prefix_from_dump || true)
    if [[ -n "$raop_prefix" || $attempts -ge $((max_attempts-1)) ]]; then break; fi
    sleep 1; attempts=$((attempts+1))
  done
  # Expected deviceid: prefer shairport config hardware_address; else RAOP instance prefix
  expected_dev="$(hwaddr_from_conf || true)"
  local raop_dev=""
  if [[ -n "$raop_prefix" ]]; then raop_dev="$(colonize_mac "$raop_prefix")"; fi
  if [[ -z "$expected_dev" && -n "$raop_dev" ]]; then expected_dev="$raop_dev"; fi
  # If configured hardware_address disagrees with current RAOP prefix, prefer RAOP observation
  if [[ -n "$expected_dev" && -n "$raop_dev" && "${expected_dev,,}" != "${raop_dev,,}" ]]; then expected_dev="$raop_dev"; fi
  if [[ -z "$expected_dev" ]]; then echo "ERROR: unable to determine expected deviceid" >&2; exit 4; fi

  sel=$(select_ap2_by_deviceid "$expected_dev")
  pk=$(echo "$sel" | awk -F= '/^PK=/{print $2}' | tr -d '\r')
  deviceid=$(echo "$sel" | awk -F= '/^DEVICEID=/{print $2}' | tr -d '\r')

  if [[ -z "${pk:-}" || ${#pk} -lt 40 ]]; then
    echo "ERROR: pk missing/short in _airplay._tcp TXT (len=${#pk})" >&2
    rc=1
  fi
  if [[ -z "${deviceid:-}" || "$deviceid" =~ ^00:00:00:00:00:00$ ]]; then
    echo "ERROR: deviceid is zero or missing" >&2
    rc=1
  fi
  if [[ -n "${raop_prefix:-}" && "$raop_prefix" =~ ^0{12}$ ]]; then
    echo "ERROR: _raop instance prefix is zero (unselectable endpoint)" >&2
    rc=1
  fi

  # If identity was reset since last verification, ensure pk changed
  local inst_mtime prev_inst_mtime prev_pk
  inst_mtime="$(stat_mtime "$INSTANCE_FILE" || true)"
  prev_inst_mtime="$(read_verify_json instance_mtime || true)"
  prev_pk="$(read_verify_json last_pk || true)"
  if [[ -n "$inst_mtime" && -n "$prev_inst_mtime" && "$inst_mtime" != "$prev_inst_mtime" ]]; then
    if [[ -n "$prev_pk" && "$prev_pk" == "$pk" ]]; then
      echo "ERROR: pk did not change after identity reset (instance.json mtime changed)" >&2
      rc=1
    fi
  fi

  # Cache current observation
  write_verify_json "$h" "$pk" "$deviceid" "$inst_mtime"

  local pkshort
  pkshort="${pk:0:8}...${pk: -8} (len=${#pk})"
  if [[ $rc -eq 0 ]]; then
    echo "${h} iface=${iface:-unknown} deviceid=${deviceid} pk=${pkshort} status=OK"
  else
    echo "${h} iface=${iface:-unknown} deviceid=${deviceid:-unknown} pk=${pkshort:-unknown} status=FAIL"
  fi
  exit $rc
}

main "$@"
