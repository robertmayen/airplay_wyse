#!/usr/bin/env bash
set -euo pipefail

# Ensure unique AirPlay 2 identity and sane defaults before shairport starts.
# - Resets copied AP2 state on first-run or fingerprint change
# - Ensures AirPlay 2 device identity is non-zero and per-host by setting
#   general.airplay_device_id from the NIC MAC (or a stable synthetic fallback).
#   See: Shairport-Sync docs on general.airplay_device_id; controllers use TXT `pk` for AP2 identity (OpenAirplay).
#   RAOP instance names derive from a MAC-like prefix; all-zeros correlates with unselectable endpoints
#   (OpenAirplay service_discovery; Shairport issue #1657).
# - Ensures a unique default name (Wyse DAC-<MACSUFFIX>) if name is generic
# - Sets interface coherently and validates non-zero deviceid

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
LIB_SH="$SCRIPT_DIR/lib.sh"
CONF="/etc/shairport-sync.conf"
DEFAULTS_FILE="/etc/default/airplay_wyse"

# shellcheck disable=SC1091
[[ -f "$DEFAULTS_FILE" ]] && source "$DEFAULTS_FILE" || true

# shellcheck disable=SC1091
[[ -f "$LIB_SH" ]] && source "$LIB_SH" || { echo "[identity] missing lib: $LIB_SH" >&2; exit 0; }

log() { echo "$(ts) [identity] $*"; }

FORCE=0
# Bound the wait for network and machine-id stabilisation to avoid races on first boot.
# Default to 20s to cover slow NIC bring-up or deferred machine-id generation.
NETWORK_WAIT_SECS=${AIRPLAY_WYSE_WAIT_SECS:-20}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force) FORCE=1 ;;
      -h|--help)
cat <<'EOF'
Usage: identity-ensure [--force]
Ensures unique AirPlay 2 identity and sane defaults.
  --force   Reset identity unconditionally (clears /var/lib/shairport-sync)
EOF
        exit 0
        ;;
      *) log "unknown argument: $1"; exit 1 ;;
    esac
    shift || true
  done
}

force_reset_identity() {
  local mac="$1"
  log "force-resetting shairport identity"
  clear_shairport_state
  ensure_state_dir
  local machine_id
  machine_id=$(cat /etc/machine-id 2>/dev/null || true)
  printf '{"machine_id":"%s","mac":"%s","forced":"%s"}\n' "$machine_id" "$mac" "$(ts)" >"$IDENTITY_FILE"
}

read_conf_value() {
  # naive reader for key in top-level sections: key = "value";
  local key="$1"
  awk -v k="$key" 'BEGIN{IGNORECASE=1} $0 ~ k"[[:space:]]*=" {match($0, /=[[:space:]]*"[^"]*"/); if (RSTART>0) {v=substr($0, RSTART+2, RLENGTH-2); gsub(/^[ \t\"]+|[ \t\"]+$/, "", v); print v; exit}}' "$CONF" 2>/dev/null || true
}

set_conf_value() {
    local key="$1" val="$2"
    if grep -qiE "^[[:space:]]*$key[[:space:]]*=" "$CONF" 2>/dev/null; then
        sed -i -E "s|(^[[:space:]]*$key[[:space:]]*=[[:space:]]*\").*(\"[[:space:]]*;)|\\1$val\\2|I" "$CONF"
    else
        # Append in appropriate section: general for known keys
        if [[ "$key" == "name" || "$key" == "hardware_address" || "$key" == "interface" ]]; then
            awk -v k="$key" -v v="$val" '
                BEGIN { done=0 }
                /^general[[:space:]]*=[[:space:]]*\{/ { print; insec=1; next }
                insec && /^\}/ && done==0 { 
                    print "    " k " = \"" v "\";"
                    print
                    insec=0
                    done=1
                    next
                }
                { print }
                END {
                    if (done==0) {
                        print "general = {"
                        print "    " k " = \"" v "\";"
                        print "};"
                    }
                }
            ' "$CONF" > "$CONF.tmp" && mv "$CONF.tmp" "$CONF"
        else
            echo "$key = \"$val\";" >> "$CONF"
        fi
    fi
}

# Read numeric/libconfig value (no quotes), e.g. airplay_device_id = 0xAABBCCDDEEFFL;
read_conf_numeric() {
  local key="$1"
  awk -v k="$key" 'BEGIN{IGNORECASE=1} $0 ~ "^[[:space:]]*"k"[[:space:]]*=" {
      match($0, /=[[:space:]]*[^;]+;/);
      if (RSTART>0) {
        v=substr($0, RSTART+1, RLENGTH-2);
        gsub(/^[ \t]+|[ \t]+$/, "", v);
        print v; exit
      }
    }' "$CONF" 2>/dev/null || true
}

# Write raw (unquoted) value, e.g. airplay_device_id = 0xAABB...L;
set_conf_value_raw() {
  local key="$1" val="$2"
  if grep -qiE "^[[:space:]]*$key[[:space:]]*=" "$CONF" 2>/dev/null; then
    # Replace any existing scalar up to the semicolon
    sed -i -E "s|(^[[:space:]]*$key[[:space:]]*=[[:space:]]*)[^;]+;|\\1$val;|I" "$CONF"
  else
    # Insert into general section if known key
    awk -v k="$key" -v v="$val" '
      BEGIN { done=0 }
      /^general[[:space:]]*=[[:space:]]*\{/ { print; insec=1; next }
      insec && /^\}/ && done==0 {
          print "    " k " = " v ";"
          print
          insec=0
          done=1
          next
      }
      { print }
      END {
        if (done==0) {
          print "general = {"
          print "    " k " = " v ";"
          print "};"
        }
      }
    ' "$CONF" > "$CONF.tmp" && mv "$CONF.tmp" "$CONF"
  fi
}

normalize_mac() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

mac_is_zero() {
  local m
  m="$(normalize_mac "$1")"
  [[ "$m" =~ ^00:00:00:00:00:00$ ]]
}

airplay_device_id_from_mac() {
  # Convert aa:bb:cc:dd:ee:ff to 0xAABBCCDDEEFFL (libconfig integer)
  local mac_hex
  mac_hex=$(echo "$1" | tr '[:lower:]' '[:upper:]' | tr -d ':')
  printf '0x%sL\n' "$mac_hex"
}

airplay_id_is_zero() {
  # True if value parses to zero-like (0, 0x0L, 0x000...L)
  local v="$1" up
  up=$(echo "$v" | tr '[:lower:]' '[:upper:]')
  up=${up%%;}
  up=${up// /}
  [[ "$up" =~ ^0x0+L$ || "$up" == "0" ]] && return 0 || return 1
}

choose_primary_iface() {
  # Priority: env override -> default route -> first UP with carrier -> first non-loopback UP
  local override="${AIRPLAY_WYSE_IFACE:-${AVAHI_IFACE:-}}"
  if [[ -n "$override" && -d "/sys/class/net/$override" ]]; then
    echo "$override"; return 0
  fi
  if command -v ip >/dev/null 2>&1; then
    local def
    def=$(ip route 2>/dev/null | awk '/^default/ {print $5; exit}')
    if [[ -n "$def" && -d "/sys/class/net/$def" ]]; then echo "$def"; return 0; fi
  fi
  local i
  for i in /sys/class/net/*; do
    i=$(basename "$i")
    [[ "$i" == "lo" ]] && continue
    [[ -f "/sys/class/net/$i/operstate" && $(cat "/sys/class/net/$i/operstate" 2>/dev/null) == up ]] || continue
    if [[ -f "/sys/class/net/$i/carrier" && $(cat "/sys/class/net/$i/carrier" 2>/dev/null) == 1 ]]; then
      echo "$i"; return 0
    fi
  done
  for i in /sys/class/net/*; do
    i=$(basename "$i")
    [[ "$i" == "lo" ]] && continue
    [[ -f "/sys/class/net/$i/operstate" && $(cat "/sys/class/net/$i/operstate" 2>/dev/null) == up ]] || continue
    echo "$i"; return 0
  done
  return 1
}

read_mac_from_iface() {
  local iface="$1"
  [[ -n "$iface" && -f "/sys/class/net/$iface/address" ]] || { echo ""; return 0; }
  cat "/sys/class/net/$iface/address" 2>/dev/null | tr '[:upper:]' '[:lower:]' | head -n1
}

synthetic_mac_from_machine_id() {
  local mid hash hex first rest byte0
  mid=$(cat /etc/machine-id 2>/dev/null || true)
  if command -v sha256sum >/dev/null 2>&1; then
    hash=$(printf '%s' "$mid" | sha256sum | awk '{print $1}')
  else
    hash=$(printf '%s' "$mid" | shasum -a 256 | awk '{print $1}')
  fi
  hex=${hash:0:12}
  first=${hex:0:2}
  rest=${hex:2}
  # Set locally-administered (bit1) and clear multicast (bit0)
  byte0=$(( 0x$first ))
  byte0=$(( (byte0 | 0x02) & 0xFE ))
  printf '%02x:%s\n' "$byte0" "$(echo "$rest" | sed -E 's/.{2}/&:/g; s/:$//')"
}

main() {
  parse_args "$@"
  # Ensure /etc/machine-id exists and is non-empty. On first boot of a clone,
  # systemd typically (re)generates it very early; we wait briefly to avoid
  # creating identity based on an empty/duplicated machine-id.
  local mid_tries=0
  while { [[ ! -s /etc/machine-id ]] || [[ "$(cat /etc/machine-id 2>/dev/null || true)" == "" ]]; } \
        && [[ $mid_tries -lt $NETWORK_WAIT_SECS ]]; do
    sleep 1; mid_tries=$((mid_tries+1))
  done
  if [[ ! -s /etc/machine-id ]]; then
    log "machine-id not present after ${NETWORK_WAIT_SECS}s; proceeding cautiously"
  fi
  # Derive interface with bounded wait
  local iface mac name cur_name cur_hwaddr tries=0
  iface="$(choose_primary_iface || true)"
  while [[ -z "${iface:-}" && $tries -lt $NETWORK_WAIT_SECS ]]; do
    sleep 1; tries=$((tries+1)); iface="$(choose_primary_iface || true)"
  done
  if [[ -n "${iface:-}" ]]; then
    set_conf_value interface "$iface"
  else
    log "no primary interface detected; proceeding without interface binding"
  fi

  # Read MAC with retry, else synthesize from machine-id. This prevents
  # RAOP from advertising an all-zero deviceid on early boot races.
  tries=0
  mac="${HW_ADDR:-$(read_mac_from_iface "${iface:-}" || true)}"
  while { [[ -z "${mac:-}" ]] || mac_is_zero "$mac"; } && [[ $tries -lt $NETWORK_WAIT_SECS ]]; do
    sleep 1; tries=$((tries+1)); mac="${HW_ADDR:-$(read_mac_from_iface "${iface:-}" || true)}"
  done
  if [[ -z "${mac:-}" ]] || mac_is_zero "$mac"; then
    mac="$(synthetic_mac_from_machine_id)"
    log "using synthetic deviceid $mac (no real MAC available)"
  fi

  # Ensure AirPlay 2 device id is present and non-zero. We derive it from the
  # chosen MAC per Shairport-Sync guidance: general.airplay_device_id is a 48-bit
  # identifier used for AP2; controllers use `_airplay._tcp` TXT `deviceid` and
  # `pk` for identity (see OpenAirplay reverse docs).
  # References:
  # - https://github.com/openairplay/openairplay (service_discovery notes)
  # - https://github.com/mikebrady/shairport-sync/issues/1657 (RAOP/MAC notes)
  local ap2_id cur_ap2_id
  ap2_id="$(airplay_device_id_from_mac "$mac")"
  cur_ap2_id=$(read_conf_numeric airplay_device_id || true)
  if [[ -z "${cur_ap2_id:-}" ]] || airplay_id_is_zero "${cur_ap2_id:-0}"; then
    log "setting airplay_device_id to $ap2_id"
    set_conf_value_raw airplay_device_id "$ap2_id"
  fi

  # Ensure RAOP (AirPlay 1) does not advertise an all-zero prefix by providing
  # a non-zero hardware_address when missing or zero. This affects the RAOP
  # service instance name, which uses a MAC-like prefix; all-zeros correlate
  # with unselectable endpoints.
  # References:
  # - OpenAirplay service_discovery; Shairport issue #1657
  local cur_hwaddr target_mac needs_update
  cur_hwaddr=$(read_conf_value hardware_address || true)
  target_mac=$(echo "$mac" | tr '[:upper:]' '[:lower:]')
  needs_update=0
  if [[ -z "${cur_hwaddr:-}" ]]; then needs_update=1; fi
  if mac_is_zero "${cur_hwaddr:-00:00:00:00:00:00}"; then needs_update=1; fi
  if [[ "${cur_hwaddr:-}" != "$target_mac" ]]; then needs_update=1; fi
  if [[ $needs_update -eq 1 ]]; then
    log "setting hardware_address (RAOP) to $target_mac"
    set_conf_value hardware_address "$target_mac"
  fi

  # Ensure a unique default name if name missing or generic
  cur_name=$(read_conf_value name || true)
  if [[ -z "${cur_name:-}" || "$cur_name" =~ ^Wyse[[:space:]]+DAC$ ]]; then
    name="$(default_airplay_name "${mac:-}")"
    log "setting default name to $name"
    set_conf_value name "$name"
  fi

  # Optional multi-instance offset (document-only; not modified here)

  # Reset identity (forced or fingerprint-based)
  if [[ $FORCE -eq 1 ]]; then
    force_reset_identity "${mac:-}"
  else
    maybe_reset_identity "${mac:-}"
  fi

  # Lint: ensure non-zero AirPlay 2 deviceid present in config
  local post_ap2
  post_ap2=$(read_conf_numeric airplay_device_id || true)
  if [[ -z "${post_ap2:-}" ]] || airplay_id_is_zero "${post_ap2:-0}"; then
    log "airplay_device_id missing or zero in config"
    exit 1
  fi
}

main "$@"
