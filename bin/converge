#!/usr/bin/env bash
set -euo pipefail

# AirPlay Wyse converge orchestrator (idempotent skeleton)

REPO_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"
STATE_DIR="/var/lib/airplay_wyse"
RUN_DIR="/run/airplay"
QUEUE_DIR="$RUN_DIR/queue"
ETC_DIR="/etc/airplay_wyse"

EXIT_OK=0
EXIT_CHANGED=2
EXIT_DEGRADED=3
EXIT_INV=4
EXIT_VERIFY=5
EXIT_HELD=6
EXIT_PKG=10
EXIT_SYSTEMD=11

log() { echo "$(date --iso-8601=seconds) [converge] $*"; }
fail() { log "ERROR: $*"; exit 1; }

enqueue_cmd() {
  # Write a one-line root command into the broker queue; broker executes if allow-listed.
  local line="$*"
  local ts rand f
  ts=$(date +%s)
  rand=$(od -An -N2 -tx2 /dev/urandom | tr -d ' \n')
  f="$QUEUE_DIR/${ts}.${rand}.cmd"
  printf '%s\n' "$line" >"$f"
}

ensure_dirs() {
  # State dir may be created by provisioning; create lazily if writable.
  mkdir -p "$STATE_DIR" 2>/dev/null || true
  mkdir -p "$STATE_DIR/hashes" 2>/dev/null || true
  # Queue dir should be present via systemd.path MakeDirectory; fall back if missing.
  mkdir -p "$QUEUE_DIR" 2>/dev/null || true
}

emit_health() {
  local status="$1" code="$2" reason="$3"
  local json
  json=$(jq -n --arg status "$status" --arg reason "$reason" --arg version "$(cat "$REPO_DIR/VERSION" 2>/dev/null || echo unknown)" '{status:$status, reason:$reason, version:$version, ts: now|tojson}') || json="{}"
  local tmpj; tmpj=$(mktemp)
  printf "%s\n" "$json" >"$tmpj"
  install -m 0644 "$tmpj" "$STATE_DIR/last-health.json" 2>/dev/null || true
  rm -f "$tmpj"
  local tmpt; tmpt=$(mktemp)
  echo "status=$status code=$code reason=$reason" >"$tmpt"
  install -m 0644 "$tmpt" "$STATE_DIR/last-health.txt" 2>/dev/null || true
  rm -f "$tmpt"
  return "$code"
}

host_key() {
  hostname -s | tr '[:upper:]' '[:lower:]'
}

verify_signed_tag() {
  # Optional GPG verification of current tag; disabled by default.
  # Enable with AIRPLAY_VERIFY_TAGS=1 or inventory key `verify_gpg: true`.
  if ! command -v git >/dev/null; then
    log "git not found; skipping verification"
    return 0
  fi
  local verify_flag tag
  verify_flag="${AIRPLAY_VERIFY_TAGS:-}"
  if [[ -z "$verify_flag" && -n "${INVENTORY_FILE:-}" && -f "$INVENTORY_FILE" ]]; then
    if grep -Eiq '^verify_gpg:\s*(true|yes|1)\b' "$INVENTORY_FILE"; then
      verify_flag=1
    else
      verify_flag=0
    fi
  fi
  verify_flag=${verify_flag:-0}

  if [[ "$verify_flag" != "1" ]]; then
    log "GPG tag verification disabled (using SSH/Git SHA workflows)"
    return 0
  fi

  if ! tag=$(git -C "$REPO_DIR" describe --tags --exact-match 2>/dev/null); then
    log "Not on a tag; verification failed"
    return 1
  fi
  if ! git -C "$REPO_DIR" verify-tag "$tag" >/dev/null 2>&1; then
    log "Tag $tag failed signature verification"
    return 1
  fi
  log "Verified signed tag: $tag"
  return 0
}

held_check() {
  if [[ -f "$ETC_DIR/hold" || -f "$STATE_DIR/hold" ]]; then
    emit_health "held" "$EXIT_HELD" "hold file present" >/dev/null || true
    exit "$EXIT_HELD"
  fi
}

load_inventory() {
  local host=$(host_key)
  local inv="$REPO_DIR/inventory/hosts/${host}.yml"
  [[ -f "$inv" ]] || { log "inventory missing for host $host"; return 1; }
  INVENTORY_FILE="$inv"
}

yaml_get() {
  # very small helper to extract simple key: value (no nesting beyond one dot)
  local key="$1"
  grep -E "^${key}:[[:space:]]" "$INVENTORY_FILE" | sed -E "s/^${key}:[[:space:]]*//" | tr -d '"'
}

time_sync_ok() {
  local ntp sys
  ntp=$(timedatectl show -p NTPSynchronized --value 2>/dev/null || echo no)
  sys=$(timedatectl show -p SystemClockSynchronized --value 2>/dev/null || echo no)
  [[ "$ntp" == "yes" || "$sys" == "yes" ]]
}

sha256_file() { sha256sum "$1" | awk '{print $1}'; }

render_template() {
  # Simple placeholder replacement using envsubst-style variables
  local src="$1" dst="$2"
  local tmp
  tmp=$(mktemp)
  cp "$src" "$tmp"
  sed -i "s/{{AIRPLAY_NAME}}/${AIRPLAY_NAME//\//\/}/g" "$tmp"
  sed -i "s/{{ALSA_DEVICE}}/${ALSA_DEVICE//\//\/}/g" "$tmp"
  sed -i "s/{{AVAHI_IFACE}}/${AVAHI_IFACE//\//\/}/g" "$tmp"
  sed -i "s/{{ALSA_MIXER}}/${ALSA_MIXER//\//\/}/g" "$tmp"
  # Write rendered file to a temp path owned by airplay; a root copy, if needed, must be enqueued externally.
  install -m 0644 "$tmp" "$dst" 2>/dev/null || true
  rm -f "$tmp"
}

needs_update() {
  local file="$1" key="$2" cur new
  new=$(sha256_file "$file")
  cur=""
  [[ -f "$STATE_DIR/hashes/$key" ]] && cur=$(cat "$STATE_DIR/hashes/$key")
  if [[ "$new" != "$cur" ]]; then
    local tmph; tmph=$(mktemp); echo "$new" >"$tmph"
    install -m 0600 "$tmph" "$STATE_DIR/hashes/$key" 2>/dev/null || true
    rm -f "$tmph"
    return 0
  fi
  return 1
}

resolve_alsa_device() {
  # Auto-detect resolver (USB preferred, then PCI/built-in). Optional inventory override via alsa.vendor_id/product_id.
  # Sets: ALSA_DEVICE (string) and ALSA_CARD (numeric card index used for mixer detection).
  local vid pid serial devnum
  vid=$(yaml_get 'alsa.vendor_id' || true)
  pid=$(yaml_get 'alsa.product_id' || true)
  serial=$(yaml_get 'alsa.serial' || true)
  devnum=$(yaml_get 'alsa.device_num' || true)
  devnum=${devnum:-0}

  ALSA_CARD=""

  # Helper: first playback device number for a card index
  first_playback_devnum_for_card() {
    local card_idx="$1"
    local d
    for d in /proc/asound/card"$card_idx"/pcm*p; do
      [[ -e "$d" ]] || continue
      d=$(basename "$d") # e.g., pcm0p
      echo "${d#pcm}" | tr -d 'p'
      return 0
    done
    return 1
  }

  # Helper: resolve by-id symlink to card index if possible
  card_index_from_byid() {
    local path="$1" real
    real=$(readlink -f "$path" 2>/dev/null || true)
    if [[ "$real" =~ /dev/snd/.*C([0-9]+)D[0-9]+ ]]; then
      echo "${BASH_REMATCH[1]}"
      return 0
    fi
    echo ""
    return 1
  }

  # 1) Inventory override (USB by VID:PID with optional serial)
  if [[ -n "${vid:-}" && -n "${pid:-}" ]]; then
    local byid target
    byid="/dev/snd/by-id"
    if [[ -d "$byid" ]]; then
      for n in "$byid"/*; do
        [[ -e "$n" ]] || continue
        if [[ "$n" == *"_${vid}_${pid}"* ]] || [[ "$n" == *"${vid}:${pid}"* ]]; then
          if [[ -z "$serial" || "$n" == *"${serial}"* ]]; then
            target="$n"; break
          fi
        fi
      done
    fi
    if [[ -n "${target:-}" ]]; then
      ALSA_DEVICE="$target"
      ALSA_CARD=$(card_index_from_byid "$target" || true)
      if [[ -z "${ALSA_CARD:-}" ]]; then
        # Fallback resolve card index via sysfs VID:PID
        for cpath in /sys/class/sound/card*/device; do
          [[ -d "$cpath" ]] || continue
          local udevdir="$(dirname "$cpath")/.."
          if [[ -f "$udevdir/idVendor" && -f "$udevdir/idProduct" ]]; then
            local fv fp fs
            fv=$(cat "$udevdir/idVendor")
            fp=$(cat "$udevdir/idProduct")
            fs=$(cat "$udevdir/serial" 2>/dev/null || echo)
            if [[ "0x$fv" == "$vid" && "0x$fp" == "$pid" ]]; then
              if [[ -z "$serial" || "$fs" == "$serial" ]]; then
                local card
                card=$(basename "$(dirname "$cpath")"); card=${card#card}
                ALSA_CARD="$card"; break
              fi
            fi
          fi
        done
      fi
      return 0
    fi
    log "ALSA override VID:PID not found; falling back to auto-detect"
  fi

  # 2) Auto-detect — USB first
  local card_dir usb_candidate="" usb_devnum=""
  for card_dir in /sys/class/sound/card*; do
    [[ -d "$card_dir" ]] || continue
    local cidx; cidx=$(basename "$card_dir"); cidx=${cidx#card}
    local udevdir="$card_dir/device/.."
    if [[ -f "$udevdir/idVendor" && -f "$udevdir/idProduct" ]]; then
      local pnum
      if pnum=$(first_playback_devnum_for_card "$cidx" 2>/dev/null); then
        usb_candidate="$cidx"; usb_devnum="$pnum"; break
      fi
    fi
  done
  if [[ -n "${usb_candidate:-}" ]]; then
    ALSA_CARD="$usb_candidate"
    ALSA_DEVICE="plughw:${ALSA_CARD},${usb_devnum}"
    return 0
  fi

  # 3) Fallback — first card with playback (PCI/built-in)
  for card_dir in /sys/class/sound/card*; do
    [[ -d "$card_dir" ]] || continue
    local cidx; cidx=$(basename "$card_dir"); cidx=${cidx#card}
    local pnum
    if pnum=$(first_playback_devnum_for_card "$cidx" 2>/dev/null); then
      ALSA_CARD="$cidx"
      ALSA_DEVICE="plughw:${ALSA_CARD},${pnum}"
      return 0
    fi
  done

  return 1
}

# Determine ALSA mixer control with override and sensible defaults
resolve_alsa_mixer() {
  local inv_mix
  inv_mix=$(yaml_get 'alsa.mixer' || true)
  if [[ -n "${inv_mix:-}" ]]; then
    ALSA_MIXER="$inv_mix"
    return 0
  fi
  ALSA_MIXER="Digital"
  if command -v amixer >/dev/null 2>&1 && [[ -n "${ALSA_CARD:-}" ]]; then
    local names
    names=$(amixer -c "$ALSA_CARD" scontrols 2>/dev/null | awk -F"'" '/Simple mixer control/ {print $2}') || names=""
    local cand
    for cand in PCM Master Digital Speaker Headphone "Line Out"; do
      if echo "$names" | grep -qx "$cand"; then
        ALSA_MIXER="$cand"; break
      fi
    done
  fi
  return 0
}

apply_packages() {
  set +e
  "$REPO_DIR/pkg/install.sh"
  local rc=$?
  set -e
  # Treat 0 = no changes, 1 = changes enqueued as success. Any rc >=2 is failure.
  if [[ $rc -ge 2 ]]; then
    log "package install/update failed"
    return 2
  fi
  PACKAGES_CHANGED=$rc
  return 0
}

apply_configs() {
  local changed=0
  AIRPLAY_NAME=$(yaml_get 'airplay_name')
  AVAHI_IFACE=$(yaml_get 'nic')

  if ! resolve_alsa_device; then
    log "ALSA device not found (auto-detect/override)"
    return 2
  fi
  resolve_alsa_mixer || true

  # shairport-sync (render into tmp and request a restart via broker if needed)
  local tmp_ss; tmp_ss=$(mktemp)
  render_template "$REPO_DIR/cfg/shairport-sync.conf.tmpl" "$tmp_ss"
  if [[ -f "/etc/shairport-sync.conf" ]]; then
    if ! cmp -s "$tmp_ss" "/etc/shairport-sync.conf"; then
      changed=1
      enqueue_cmd /usr/bin/systemctl restart airplay-shairport
    fi
  fi
  rm -f "$tmp_ss"

  # avahi iface restrict (optional)
  if [[ -f "$REPO_DIR/cfg/avahi/avahi-daemon.conf.d/airplay-wyse.conf.tmpl" ]]; then
    # Render to temp; copy + restart handled via broker if policy later allows.
    local tmp_av; tmp_av=$(mktemp)
    render_template "$REPO_DIR/cfg/avahi/avahi-daemon.conf.d/airplay-wyse.conf.tmpl" "$tmp_av"
    if [[ -f "/etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf" ]] && ! cmp -s "$tmp_av" "/etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf"; then
      changed=1
      enqueue_cmd /usr/bin/systemctl restart airplay-avahi
    fi
    rm -f "$tmp_av"
  fi

  return $changed
}

check_nqptp_health() {
  # If nqptp is not installed (no unit present), treat as optional OK.
  if ! systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    return 0
  fi
  # Unit exists; ensure it's active
  if ! systemctl is-active --quiet nqptp.service; then
    return 1
  fi
  return 0
}

check_avahi_raop() {
  command -v avahi-browse >/dev/null || return 0
  avahi-browse -rt _airplay._tcp 2>/dev/null | grep -q "${AIRPLAY_NAME}" || return 1
  avahi-browse -rt _raop._tcp 2>/dev/null | grep -q "${AIRPLAY_NAME}" || return 1
  return 0
}

main() {
  ensure_dirs
  held_check
  if ! load_inventory; then
    emit_health "invalid_inventory" "$EXIT_INV" "missing inventory file" >/dev/null || true
    exit "$EXIT_INV"
  fi
  if ! verify_signed_tag; then
    emit_health "verify_failed" "$EXIT_VERIFY" "unsigned or invalid tag" >/dev/null || true
    exit "$EXIT_VERIFY"
  fi
  if ! time_sync_ok; then
    emit_health "degraded" "$EXIT_DEGRADED" "time unsynced" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi

  # Package ensure
  PACKAGES_CHANGED=0
  if ! apply_packages; then
    emit_health "pkg_failed" "$EXIT_PKG" "package install/update failed" >/dev/null || true
    exit "$EXIT_PKG"
  fi

  # Enqueue service restarts as needed; enabling is intentionally left to provisioning or packages

  # Apply configs and possibly restart services
  set +e
  apply_configs
  local cfg_rc=$?
  set -e
  if [[ $cfg_rc -eq 2 ]]; then
    emit_health "degraded" "$EXIT_DEGRADED" "alsa device missing" >/dev/null || true
    exit "$EXIT_DEGRADED"
  elif [[ $cfg_rc -eq 3 ]]; then
    emit_health "systemd_failed" "$EXIT_SYSTEMD" "service restart failed" >/dev/null || true
    exit "$EXIT_SYSTEMD"
  fi

  # Health checks
  if ! check_nqptp_health; then
    emit_health "degraded" "$EXIT_DEGRADED" "nqptp not healthy" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  if ! check_avahi_raop; then
    emit_health "degraded" "$EXIT_DEGRADED" "avahi/raop not visible" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi

  if [[ $cfg_rc -eq 1 || ${PACKAGES_CHANGED:-0} -eq 1 ]]; then
    emit_health "healthy_changed" "$EXIT_CHANGED" "changes applied or enqueued root ops" >/dev/null || true
    exit "$EXIT_CHANGED"
  fi
  emit_health "healthy" "$EXIT_OK" "no changes" >/dev/null || true
  exit "$EXIT_OK"
}

main "$@"
