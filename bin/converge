#!/usr/bin/env bash
set -euo pipefail

# AirPlay Wyse converge orchestrator (idempotent skeleton)

REPO_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"
STATE_DIR="/var/lib/airplay_wyse"
RUN_DIR="/run/airplay"
ETC_DIR="/etc/airplay_wyse"

EXIT_OK=0
EXIT_CHANGED=2
EXIT_DEGRADED=3
EXIT_INV=4
EXIT_VERIFY=5
EXIT_HELD=6
EXIT_PKG=10
EXIT_SYSTEMD=11

log() { echo "$(date --iso-8601=seconds) [converge] $*"; }
fail() { log "ERROR: $*"; exit 1; }

systemd_run() {
  # Usage: systemd_run <profile> -- <command...>
  local profile="$1"; shift; [[ "${1:-}" == "--" ]] && shift || true
  if [[ -x /usr/local/sbin/airplay-sd-run ]]; then
    sudo /usr/local/sbin/airplay-sd-run "$profile" -- "$*"
    return $?
  fi
  # Bootstrap fallback for first-run: use direct systemd-run with hardened props
  local host; host=$(hostname -s 2>/dev/null || hostname)
  local run_id; run_id=$(od -An -N4 -tx4 /dev/urandom | tr -d ' \n')
  local unit="airplay-tx-${host}-${profile}-${run_id}"
  local desc="airplay-${host} ${unit} CAP=${profile} RUN_ID=${run_id}"
  local props=(
    --unit "$unit" --collect --quiet --wait
    --property=Type=exec
    --property=SyslogIdentifier=airplay-agent
    --property=Description="$desc"
    --property=NoNewPrivileges=yes
    --property=ProtectHome=read-only
    --property=ProtectSystem=strict
    --property=PrivateTmp=yes
    --property=CapabilityBoundingSet=
    --property=DevicePolicy=closed
    --property=LockPersonality=yes
    --property=MemoryDenyWriteExecute=yes
  )
  case "$profile" in
    cfg-write) props+=( --property=ReadWritePaths=/etc ) ;;
    unit-write) props+=( --property=ReadWritePaths=/etc/systemd/system ) ;;
    pkg-ensure) props+=( --property=ReadWritePaths=/var/cache/apt --property=ReadWritePaths=/var/lib/apt \
                         --property=ReadWritePaths=/var/lib/dpkg --property=ReadWritePaths=/var/log \
                         --property=ReadWritePaths=/etc/apt --property=ReadWritePaths=/opt/airplay_wyse/pkg \
                         --property=ReadWritePaths=/tmp --property=ReadWritePaths=/var/tmp ) ;;
    svc-restart) : ;;
  esac
  sudo /usr/bin/systemd-run "${props[@]}" /bin/bash -lc "$*"
  return $?
}

# Bootstrap sudo/sudoers and wrapper to enable privilege model
bootstrap_sudo_config() {
  # Returns: 0 success, 1 failed, 4 needs manual intervention
  local need_manual=4
  local failed=1

  # Helper: check if current user (or airplay when root) can sudo systemd-run without password
  can_sudo_nopass() {
    if ! command -v sudo >/dev/null 2>&1; then return 1; fi
    if [[ $(id -u) -eq 0 ]]; then
      # As root, test from the airplay account context
      if id -u airplay >/dev/null 2>&1; then
        sudo -u airplay -n sudo -n /usr/bin/systemd-run --version >/dev/null 2>&1
        return $?
      fi
      return 1
    else
      sudo -n /usr/bin/systemd-run --version >/dev/null 2>&1
      return $?
    fi
  }

  # Fast-path: already configured
  if can_sudo_nopass; then
    # Ensure wrapper exists; if root, fix it, else just warn via log.
    if [[ ! -x /usr/local/sbin/airplay-sd-run ]]; then
      local src="$REPO_DIR/scripts/airplay-sd-run"
      if [[ -f "$src" && $(id -u) -eq 0 ]]; then
        install -o root -g root -m 0755 "$src" /usr/local/sbin/airplay-sd-run || return $failed
      elif [[ -f "$src" ]]; then
        log "airplay-sd-run wrapper missing; will rely on direct systemd-run via sudo"
      fi
    fi
    # Validate wrapper usage (best-effort)
    if [[ $(id -u) -eq 0 ]]; then
      sudo -u airplay -n /usr/local/sbin/airplay-sd-run svc-restart -- /bin/true >/dev/null 2>&1 || true
    else
      sudo -n /usr/local/sbin/airplay-sd-run svc-restart -- /bin/true >/dev/null 2>&1 || true
    fi
    return $EXIT_OK
  fi

  # Not configured; if root, create minimal sudoers and install wrapper
  if [[ $(id -u) -eq 0 ]]; then
    # Create sudoers drop-in
    mkdir -p /etc/sudoers.d || return $failed
    local sdfile=/etc/sudoers.d/airplay-wyse
    local tmp; tmp=$(mktemp -p /var/tmp)
    {
      echo "# AirPlay Wyse privilege model (NOPASSWD systemd-run for airplay)"
      echo "Defaults:airplay !requiretty"
      echo "airplay ALL=(root) NOPASSWD: /usr/bin/systemd-run"
    } >"$tmp"
    install -o root -g root -m 0440 "$tmp" "$sdfile" || { rm -f "$tmp"; return $failed; }
    rm -f "$tmp"
    if command -v visudo >/dev/null 2>&1; then
      if ! visudo -cf "$sdfile" >/dev/null 2>&1; then
        log "sudoers validation failed for $sdfile"
        return $failed
      fi
    fi
    # Install wrapper
    local src="$REPO_DIR/scripts/airplay-sd-run"
    if [[ -f "$src" ]]; then
      install -o root -g root -m 0755 "$src" /usr/local/sbin/airplay-sd-run || return $failed
    else
      log "wrapper script missing at $src; proceed without (direct systemd-run only)"
    fi
    # Validate from airplay context
    if id -u airplay >/dev/null 2>&1; then
      if ! sudo -u airplay -n sudo -n /usr/bin/systemd-run --version >/dev/null 2>&1; then
        log "sudo still not permitting NOPASSWD systemd-run for airplay"
        return $failed
      fi
    fi
    return $EXIT_OK
  fi

  # Non-root and sudo not configured: provide manual instructions
  log "CRITICAL: sudo not configured for airplay. Bootstrap required."
  log "Manual recovery (as root):"
  log "  install -d -m 0755 /etc/sudoers.d"
  log "  printf 'airplay ALL=(root) NOPASSWD: /usr/bin/systemd-run\n' > /etc/sudoers.d/airplay-wyse"
  log "  chmod 0440 /etc/sudoers.d/airplay-wyse && visudo -cf /etc/sudoers.d/airplay-wyse"
  log "  install -o root -g root -m 0755 $REPO_DIR/scripts/airplay-sd-run /usr/local/sbin/airplay-sd-run"
  return $need_manual
}

ensure_dirs() {
  # State dir may be created by provisioning; create lazily if writable.
  mkdir -p "$STATE_DIR" 2>/dev/null || true
  mkdir -p "$STATE_DIR/hashes" 2>/dev/null || true
  : # no queue; transient privileged actions via systemd-run
}

# GitOps: ensure systemd units on device match repo; bootstrap broker sandbox if needed.
sync_systemd_units() {
  local changed=0
  # Ensure systemd units on device match repo; write directly via transient unit

  for src in "$REPO_DIR"/systemd/*.service "$REPO_DIR"/systemd/*.path; do
    [[ -f "$src" ]] || continue
    local base dest
    base=$(basename "$src")
    dest="/etc/systemd/system/$base"
    if [[ ! -f "$dest" ]] || ! cmp -s "$src" "$dest"; then
      systemd_run unit-write -- \
        "/usr/bin/install -m 0644 '$src' '$dest'"
      changed=1
    fi
  done
  # Ensure converge drop-in override mirrors SuccessExitStatus
  local conv_ov_src="$REPO_DIR/systemd/overrides/converge.service.d/override.conf"
  if [[ -f "$conv_ov_src" ]]; then
    systemd_run unit-write -- "/usr/bin/install -d -m 0755 /etc/systemd/system/converge.service.d"
    systemd_run unit-write -- "/usr/bin/install -m 0644 '$conv_ov_src' /etc/systemd/system/converge.service.d/override.conf"
    changed=1
  fi
  if [[ $changed -eq 1 ]]; then
    systemd_run svc-restart -- "/usr/bin/systemctl daemon-reload"
    # Log SuccessExitStatus configured for converge.service for verification
    local ses
    ses=$(systemctl show -p SuccessExitStatus --value converge.service 2>/dev/null || echo)
    log "converge.service SuccessExitStatus='${ses}'"
  fi
  # Remove deprecated units (.path and broker) if present
  local obsolete=(
    /etc/systemd/system/update-done.path
    /etc/systemd/system/converge-broker.path
    /etc/systemd/system/converge-broker.service
  )
  local removed=0 u
  for u in "${obsolete[@]}"; do
    if [[ -f "$u" ]]; then
      local uname; uname=$(basename "$u")
      systemd_run svc-restart -- "/usr/bin/systemctl stop '$uname' || true"
      systemd_run svc-restart -- "/usr/bin/systemctl disable '$uname' || true"
      systemd_run unit-write -- "/bin/rm -f '$u'"
      removed=1
    fi
  done
  if [[ $removed -eq 1 ]]; then
    systemd_run svc-restart -- "/usr/bin/systemctl daemon-reload"
  fi
}

emit_health() {
  local status="$1" code="$2" reason="$3"
  local json
  json=$(jq -n --arg status "$status" --arg reason "$reason" --arg version "$(cat "$REPO_DIR/VERSION" 2>/dev/null || echo unknown)" '{status:$status, reason:$reason, version:$version, ts: now|tojson}') || json="{}"
  local tmpj; tmpj=$(mktemp -p /var/tmp)
  printf "%s\n" "$json" >"$tmpj"
  install -m 0644 "$tmpj" "$STATE_DIR/last-health.json" 2>/dev/null || true
  rm -f "$tmpj"
  local tmpt; tmpt=$(mktemp -p /var/tmp)
  echo "status=$status code=$code reason=$reason" >"$tmpt"
  install -m 0644 "$tmpt" "$STATE_DIR/last-health.txt" 2>/dev/null || true
  rm -f "$tmpt"
  return "$code"
}

host_key() {
  hostname -s | tr '[:upper:]' '[:lower:]'
}

verify_signed_tag() {
  # Optional GPG verification of current tag; disabled by default.
  # Enable with AIRPLAY_VERIFY_TAGS=1 or inventory key `verify_gpg: true`.
  if ! command -v git >/dev/null; then
    log "git not found; skipping verification"
    return 0
  fi
  local verify_flag tag
  verify_flag="${AIRPLAY_VERIFY_TAGS:-}"
  if [[ -z "$verify_flag" && -n "${INVENTORY_FILE:-}" && -f "$INVENTORY_FILE" ]]; then
    if grep -Eiq '^verify_gpg:\s*(true|yes|1)\b' "$INVENTORY_FILE"; then
      verify_flag=1
    else
      verify_flag=0
    fi
  fi
  verify_flag=${verify_flag:-0}

  if [[ "$verify_flag" != "1" ]]; then
    log "GPG tag verification disabled (using SSH/Git SHA workflows)"
    return 0
  fi

  if ! tag=$(git -C "$REPO_DIR" describe --tags --exact-match 2>/dev/null); then
    log "Not on a tag; verification failed"
    return 1
  fi
  if ! git -C "$REPO_DIR" verify-tag "$tag" >/dev/null 2>&1; then
    log "Tag $tag failed signature verification"
    return 1
  fi
  log "Verified signed tag: $tag"
  return 0
}

held_check() {
  if [[ -f "$ETC_DIR/hold" || -f "$STATE_DIR/hold" ]]; then
    emit_health "held" "$EXIT_HELD" "hold file present" >/dev/null || true
    exit "$EXIT_HELD"
  fi
}

load_inventory() {
  local host=$(host_key)
  local inv="$REPO_DIR/inventory/hosts/${host}.yml"
  if [[ -f "$inv" ]]; then
    INVENTORY_FILE="$inv"
    return 0
  fi
  log "inventory missing for host $host; proceeding with auto-detect defaults"
  INVENTORY_FILE=""
  return 0
}

yaml_get() {
  # very small helper to extract simple key: value (no nesting beyond one dot)
  local key="$1"
  if [[ -n "${INVENTORY_FILE:-}" && -f "$INVENTORY_FILE" ]]; then
    grep -E "^${key}:[[:space:]]" "$INVENTORY_FILE" | sed -E "s/^${key}:[[:space:]]*//" | tr -d '"'
  else
    echo ""
  fi
}

time_sync_ok() {
  local ntp sys
  ntp=$(timedatectl show -p NTPSynchronized --value 2>/dev/null || echo no)
  sys=$(timedatectl show -p SystemClockSynchronized --value 2>/dev/null || echo no)
  [[ "$ntp" == "yes" || "$sys" == "yes" ]]
}

sha256_file() { sha256sum "$1" | awk '{print $1}'; }

render_template() {
  # Simple placeholder replacement using envsubst-style variables
  local src="$1" dst="$2"
  local tmp
  tmp=$(mktemp -p /var/tmp)
  cp "$src" "$tmp"
  sed -i "s/{{AIRPLAY_NAME}}/${AIRPLAY_NAME//\//\/}/g" "$tmp"
  sed -i "s/{{ALSA_DEVICE}}/${ALSA_DEVICE//\//\/}/g" "$tmp"
  sed -i "s/{{AVAHI_IFACE}}/${AVAHI_IFACE//\//\/}/g" "$tmp"
  sed -i "s/{{ALSA_MIXER}}/${ALSA_MIXER//\//\/}/g" "$tmp"
  # Write rendered file to a temp path owned by airplay; a root copy, if needed, must be enqueued externally.
  install -m 0644 "$tmp" "$dst" 2>/dev/null || true
  rm -f "$tmp"
}

needs_update() {
  local file="$1" key="$2" cur new
  new=$(sha256_file "$file")
  cur=""
  [[ -f "$STATE_DIR/hashes/$key" ]] && cur=$(cat "$STATE_DIR/hashes/$key")
  if [[ "$new" != "$cur" ]]; then
    local tmph; tmph=$(mktemp -p /var/tmp); echo "$new" >"$tmph"
    install -m 0600 "$tmph" "$STATE_DIR/hashes/$key" 2>/dev/null || true
    rm -f "$tmph"
    return 0
  fi
  return 1
}

resolve_alsa_device() {
  # Auto-detect resolver (USB preferred, then PCI/built-in). Optional inventory override via alsa.vendor_id/product_id.
  # Sets: ALSA_DEVICE (string) and ALSA_CARD (numeric card index used for mixer detection).
  local vid pid serial devnum
  vid=$(yaml_get 'alsa.vendor_id' || true)
  pid=$(yaml_get 'alsa.product_id' || true)
  serial=$(yaml_get 'alsa.serial' || true)
  devnum=$(yaml_get 'alsa.device_num' || true)
  devnum=${devnum:-0}

  ALSA_CARD=""

  # Helper: first playback device number for a card index
  first_playback_devnum_for_card() {
    local card_idx="$1"
    local d
    for d in /proc/asound/card"$card_idx"/pcm*p; do
      [[ -e "$d" ]] || continue
      d=$(basename "$d") # e.g., pcm0p
      echo "${d#pcm}" | tr -d 'p'
      return 0
    done
    return 1
  }

  # Helper: resolve by-id symlink to card index if possible
  card_index_from_byid() {
    local path="$1" real
    real=$(readlink -f "$path" 2>/dev/null || true)
    if [[ "$real" =~ /dev/snd/.*C([0-9]+)D[0-9]+ ]]; then
      echo "${BASH_REMATCH[1]}"
      return 0
    fi
    echo ""
    return 1
  }

  # Simple helper: try to open a PCM for a very short time (silent zeroes)
  try_open_device() {
    local dev="$1"
    # If aplay is missing, or shairport-sync is active (likely holding the device),
    # do not negatively judge the device — treat as acceptable.
    if ! command -v aplay >/dev/null 2>&1; then return 0; fi
    if systemctl is-active --quiet shairport-sync.service 2>/dev/null; then return 0; fi
    # Attempt a very short, silent open; tolerate busy/permission errors.
    local err rc tf; tf=$(mktemp -p /var/tmp)
    set +e
    timeout 1 aplay -q -t raw -c 2 -f S16_LE -r 44100 -D "$dev" < /dev/zero 2>"$tf"
    rc=$?
    set -e
    if [[ $rc -eq 0 ]]; then rm -f "$tf"; return 0; fi
    err=$(tr '\n' ' ' <"$tf" | tr -d '\r')
    rm -f "$tf"
    # Accept devices that fail due to being busy or permission limited.
    if echo "$err" | grep -Eqi 'busy|permission denied'; then return 0; fi
    # Otherwise, treat as not-openable and let the caller try other forms.
    return 1
  }

  # 1) Inventory override (USB by VID:PID with optional serial)
  if [[ -n "${vid:-}" && -n "${pid:-}" ]]; then
    local byid target
    byid="/dev/snd/by-id"
    if [[ -d "$byid" ]]; then
      for n in "$byid"/*; do
        [[ -e "$n" ]] || continue
        if [[ "$n" == *"_${vid}_${pid}"* ]] || [[ "$n" == *"${vid}:${pid}"* ]]; then
          if [[ -z "$serial" || "$n" == *"${serial}"* ]]; then
            target="$n"; break
          fi
        fi
      done
    fi
    if [[ -n "${target:-}" ]]; then
      ALSA_DEVICE="$target"
      ALSA_CARD=$(card_index_from_byid "$target" || true)
      if [[ -z "${ALSA_CARD:-}" ]]; then
        # Fallback resolve card index via sysfs VID:PID
        for cpath in /sys/class/sound/card*/device; do
          [[ -d "$cpath" ]] || continue
          local udevdir="$(dirname "$cpath")/.."
          if [[ -f "$udevdir/idVendor" && -f "$udevdir/idProduct" ]]; then
            local fv fp fs
            fv=$(cat "$udevdir/idVendor")
            fp=$(cat "$udevdir/idProduct")
            fs=$(cat "$udevdir/serial" 2>/dev/null || echo)
            if [[ "0x$fv" == "$vid" && "0x$fp" == "$pid" ]]; then
              if [[ -z "$serial" || "$fs" == "$serial" ]]; then
                local card
                card=$(basename "$(dirname "$cpath")"); card=${card#card}
                ALSA_CARD="$card"; break
              fi
            fi
          fi
        done
      fi
      # Validate device open; try common forms if needed
      local cand1="plughw:${ALSA_CARD},${devnum}"
      local cand2="hw:${ALSA_CARD},${devnum}"
      local cand3="default"
      if try_open_device "$cand1"; then ALSA_DEVICE="$cand1"; return 0; fi
      if try_open_device "$cand2"; then ALSA_DEVICE="$cand2"; return 0; fi
      if try_open_device "$cand3"; then ALSA_DEVICE="$cand3"; return 0; fi
      # Fall through to auto-detect below
    fi
    log "ALSA override VID:PID not found; falling back to auto-detect"
  fi

  # 2) Auto-detect — USB first
  local card_dir usb_candidate="" usb_devnum=""
  for card_dir in /sys/class/sound/card*; do
    [[ -d "$card_dir" ]] || continue
    local cidx; cidx=$(basename "$card_dir"); cidx=${cidx#card}
    local udevdir="$card_dir/device/.."
    if [[ -f "$udevdir/idVendor" && -f "$udevdir/idProduct" ]]; then
      local pnum
      if pnum=$(first_playback_devnum_for_card "$cidx" 2>/dev/null); then
        usb_candidate="$cidx"; usb_devnum="$pnum"; break
      fi
    fi
  done
  if [[ -n "${usb_candidate:-}" ]]; then
    ALSA_CARD="$usb_candidate"
    # Try preferred forms in order
    local cand1="plughw:${ALSA_CARD},${usb_devnum}"
    local cand2="hw:${ALSA_CARD},${usb_devnum}"
    local cand3="default"
    if try_open_device "$cand1"; then ALSA_DEVICE="$cand1"; return 0; fi
    if try_open_device "$cand2"; then ALSA_DEVICE="$cand2"; return 0; fi
    if try_open_device "$cand3"; then ALSA_DEVICE="$cand3"; return 0; fi
  fi

  # 3) Fallback — first card with playback (PCI/built-in)
  for card_dir in /sys/class/sound/card*; do
    [[ -d "$card_dir" ]] || continue
    local cidx; cidx=$(basename "$card_dir"); cidx=${cidx#card}
    local pnum
    if pnum=$(first_playback_devnum_for_card "$cidx" 2>/dev/null); then
      ALSA_CARD="$cidx"
      local cand1="plughw:${ALSA_CARD},${pnum}"
      local cand2="hw:${ALSA_CARD},${pnum}"
      local cand3="default"
      if try_open_device "$cand1"; then ALSA_DEVICE="$cand1"; return 0; fi
      if try_open_device "$cand2"; then ALSA_DEVICE="$cand2"; return 0; fi
      if try_open_device "$cand3"; then ALSA_DEVICE="$cand3"; return 0; fi
    fi
  done

  return 1
}

# Determine ALSA mixer control with override and sensible defaults
resolve_alsa_mixer() {
  local inv_mix
  inv_mix=$(yaml_get 'alsa.mixer' || true)
  if [[ -n "${inv_mix:-}" ]]; then
    ALSA_MIXER="$inv_mix"
    return 0
  fi
  ALSA_MIXER="Digital"
  if command -v amixer >/dev/null 2>&1 && [[ -n "${ALSA_CARD:-}" ]]; then
    local names
    names=$(amixer -c "$ALSA_CARD" scontrols 2>/dev/null | awk -F"'" '/Simple mixer control/ {print $2}') || names=""
    local cand
    for cand in PCM Master Digital Speaker Headphone "Line Out" Line Front; do
      if echo "$names" | grep -qx "$cand"; then
        ALSA_MIXER="$cand"; break
      fi
    done
  fi
  return 0
}

apply_packages() {
  set +e
  "$REPO_DIR/pkg/install.sh"
  local rc=$?
  set -e
  # Treat 0 = no changes, 1 = changes enqueued as success. Any rc >=2 is failure.
  if [[ $rc -ge 2 ]]; then
    log "package install/update failed"
    return 2
  fi
  PACKAGES_CHANGED=$rc
  return 0
}

sync_shairport_override() {
  # Ensure shairport-sync has an override to order after nqptp and tighten sandbox
  local src="$REPO_DIR/systemd/overrides/shairport-sync.service.d/override.conf"
  local changed=0
  if [[ -f "$src" ]]; then
    if [[ ! -d "/etc/systemd/system/shairport-sync.service.d" ]]; then
      systemd_run unit-write -- "/usr/bin/install -d -m 0755 /etc/systemd/system/shairport-sync.service.d"
      changed=1
    fi
    local dest="/etc/systemd/system/shairport-sync.service.d/override.conf"
    if [[ ! -f "$dest" ]] || ! cmp -s "$src" "$dest"; then
      systemd_run unit-write -- "/usr/bin/install -m 0644 '$src' '$dest'"
      changed=1
    fi
  fi
  if [[ $changed -eq 1 ]]; then
    systemd_run svc-restart -- "/usr/bin/systemctl daemon-reload"
    systemd_run svc-restart -- "/usr/bin/systemctl restart airplay-shairport"
  fi
  return $changed
}

ensure_nqptp_started() {
  # If nqptp service exists, ensure it's enabled and started via transient privileged unit
  if systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    if ! systemctl is-enabled --quiet nqptp.service 2>/dev/null; then
      systemd_run svc-restart -- "/usr/bin/systemctl enable nqptp.service"
    fi
    if ! systemctl is-active --quiet nqptp.service 2>/dev/null; then
      systemd_run svc-restart -- "/usr/bin/systemctl start nqptp.service"
    fi
  fi
}

has_airplay2_build() {
  # Best-effort detection: look for AirPlay 2 / RAOP2 / NQPTP in version output
  if ! command -v shairport-sync >/dev/null 2>&1; then return 1; fi
  local v
  v=$(shairport-sync -V 2>&1 || true)
  log "Checking shairport-sync for AirPlay 2 support: $(echo "$v" | head -1)"
  echo "$v" | grep -Eqi 'Air[[:space:]]*Play[[:space:]]*2|RAOP2|NQPTP' && return 0 || return 1
}

# Compatibility wrapper: preferred name
has_raop2() { has_airplay2_build; }

# nqptp activity check
nqptp_active() { systemctl is-active --quiet nqptp.service 2>/dev/null; }

# Install build dependencies for nqptp
install_nqptp_build_deps() {
  log "Installing nqptp build dependencies"
  systemd_run pkg-ensure -- \
    "/usr/bin/apt-get update -y || true; /usr/bin/apt-get install -y build-essential autoconf automake libtool pkg-config git libmd-dev libsystemd-dev"
}

# Install build dependencies for shairport-sync
install_shairport_build_deps() {
  log "Installing shairport-sync build dependencies"
  systemd_run pkg-ensure -- \
    "/usr/bin/apt-get update -y || true; /usr/bin/apt-get install -y build-essential autoconf automake libtool pkg-config git libssl-dev libavahi-client-dev libasound2-dev libsoxr-dev libconfig-dev libdbus-1-dev libplist-dev"
}

# Build nqptp from source
build_nqptp_from_source() {
  log "Building nqptp from source (APT unavailable)"
  
  # Install build dependencies
  install_nqptp_build_deps
  
  # Use existing build script with --install-directly
  if [[ -x "$REPO_DIR/pkg/build-nqptp.sh" ]]; then
    systemd_run pkg-ensure -- \
      "cd /opt/airplay_wyse && /opt/airplay_wyse/pkg/build-nqptp.sh --install-directly"
    return $?
  else
    log "Build script missing: $REPO_DIR/pkg/build-nqptp.sh"
    return 1
  fi
}

# Build shairport-sync from source with RAOP2
build_shairport_sync_from_source() {
  log "Building RAOP2-enabled shairport-sync from source"
  
  # Install build dependencies
  install_shairport_build_deps
  
  # Use existing build script with --install-directly
  if [[ -x "$REPO_DIR/pkg/build-shairport-sync.sh" ]]; then
    systemd_run pkg-ensure -- \
      "cd /opt/airplay_wyse && /opt/airplay_wyse/pkg/build-shairport-sync.sh --install-directly"
    return $?
  else
    log "Build script missing: $REPO_DIR/pkg/build-shairport-sync.sh"
    return 1
  fi
}

# Ensure nqptp is installed (APT first, then source fallback)
ensure_nqptp() {
  # Quick check: already installed and active
  if systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    if systemctl is-active --quiet nqptp.service 2>/dev/null; then
      return 0
    fi
  fi
  
  log "Ensuring nqptp installation"
  
  # 1. Try APT first (fast path)
  if command -v apt-get >/dev/null 2>&1; then
    if systemd_run pkg-ensure -- \
      "/usr/bin/apt-get update -y || true; /usr/bin/apt-get install -y nqptp"; then
      log "nqptp installed via APT"
      return 0
    fi
  fi
  
  # 2. Build from source (GitOps fallback)
  log "APT installation failed, falling back to source build"
  if build_nqptp_from_source; then
    log "nqptp built and installed from source"
    return 0
  fi
  
  log "WARNING: nqptp installation failed, AirPlay 2 may not work optimally"
  return 1
}

# Ensure RAOP2-enabled shairport-sync
ensure_raop2_shairport_sync() {
  # 1. Check if current version has RAOP2
  if has_airplay2_build; then
    log "shairport-sync already has RAOP2 support"
    return 0
  fi
  
  log "Current shairport-sync lacks RAOP2, upgrading..."
  
  # 2. Build RAOP2-enabled version from source
  if build_shairport_sync_from_source; then
    log "RAOP2-enabled shairport-sync built and installed from source"
    return 0
  fi
  
  log "WARNING: RAOP2 upgrade failed, using existing shairport-sync"
  return 1
}

# Remediate missing RAOP2 capability (install/start nqptp; upgrade shairport-sync)
remediate_raop2() {
  local need=0 changed=0
  if ! has_airplay2_build; then need=1; fi
  if ! systemctl is-active --quiet nqptp.service 2>/dev/null; then need=1; fi
  if [[ $need -eq 0 ]]; then
    echo 0; return 0
  fi

  log "RAOP2 remediation: desired_capability=RAOP2; attempting fixes"

  # Use the new ensure functions
  if ensure_nqptp; then
    changed=1
  fi
  
  if ensure_raop2_shairport_sync; then
    changed=1
  fi

  # Ensure shairport-sync drop-in uses nqptp and units are (re)loaded
  local ovsrc="$REPO_DIR/systemd/overrides/shairport-sync.service.d/override.conf"
  if [[ -f "$ovsrc" ]]; then
    systemd_run unit-write -- "/usr/bin/install -d -m 0755 /etc/systemd/system/shairport-sync.service.d"
    systemd_run unit-write -- "/usr/bin/install -m 0644 '$ovsrc' /etc/systemd/system/shairport-sync.service.d/override.conf"
    changed=1
  fi

  systemd_run svc-restart -- "/usr/bin/systemctl daemon-reload"
  # Ensure nqptp enabled/started, then restart shairport-sync
  systemd_run svc-restart -- "/usr/bin/systemctl enable nqptp.service || true"
  systemd_run svc-restart -- "/usr/bin/systemctl restart nqptp.service || /usr/bin/systemctl start nqptp.service"
  systemd_run svc-restart -- "/usr/bin/systemctl restart shairport-sync.service || true"
  changed=1

  # Post-check
  if systemctl is-active --quiet nqptp.service 2>/dev/null && has_airplay2_build; then
    log "RAOP2 remediation successful: nqptp active and shairport-sync reports AirPlay 2"
  else
    log "RAOP2 remediation attempted but verification still failing"
  fi

  echo $changed
  return 0
}

# Ensure AirPlay 2 (RAOP2) support by installing/activating nqptp and a RAOP2-capable shairport-sync
# Returns: 0 (no change), 2 (changed), 10 (package error)
ensure_airplay2_support() {
  local changed=0

  # Quick success path
  if has_airplay2_build && nqptp_active; then
    return $EXIT_OK
  fi

  log "Ensuring AirPlay 2 support (RAOP2 + nqptp)"

  # Stop shairport via wrapper to avoid device busy during dpkg
  systemd_run svc-restart -- "/usr/bin/systemctl stop airplay-shairport || true"

  # 1) Ensure nqptp installed (uses APT-first, source-fallback)
  if ! ensure_nqptp; then
    log "Failed to ensure nqptp installation"
    return $EXIT_PKG
  fi
  changed=1
  
  # Enable/start nqptp regardless
  systemd_run svc-restart -- "/usr/bin/systemctl enable nqptp.service || true"
  systemd_run svc-restart -- "/usr/bin/systemctl restart nqptp.service || /usr/bin/systemctl start nqptp.service || true"

  # 2) Ensure shairport-sync has RAOP2 capability (uses source-fallback)
  if ! ensure_raop2_shairport_sync; then
    log "Failed to ensure RAOP2-enabled shairport-sync"
    # Don't fail completely - continue with existing shairport-sync
  else
    changed=1
  fi

  # Ensure override to order after nqptp is present
  sync_shairport_override || true

  # Reload units and start services
  systemd_run svc-restart -- "/usr/bin/systemctl daemon-reload"
  systemd_run svc-restart -- "/usr/bin/systemctl restart airplay-shairport || true"
  systemd_run svc-restart -- "/usr/bin/systemctl restart airplay-avahi || true"

  # Final verification
  if ! nqptp_active || ! has_airplay2_build; then
    log "AirPlay 2 ensure failed: nqptp_active=$(nqptp_active && echo yes || echo no), has_raop2=$(has_airplay2_build && echo yes || echo no)"
    return $EXIT_PKG
  fi

  if [[ $changed -eq 1 ]]; then
    return $EXIT_CHANGED
  fi
  return $EXIT_OK
}

apply_configs() {
  local changed=0
  AIRPLAY_NAME=$(yaml_get 'airplay_name')
  AVAHI_IFACE=$(yaml_get 'nic')

  # Defaults if inventory missing/empty
  AIRPLAY_NAME=${AIRPLAY_NAME:-$(host_key)}
  if [[ -z "${AVAHI_IFACE:-}" ]]; then
    # Prefer default route device; fallback to first non-lo UP interface
    if command -v ip >/dev/null 2>&1; then
      AVAHI_IFACE=$(ip -o route show default 2>/dev/null | awk '{for(i=1;i<=NF;i++){if($i=="dev"){print $(i+1); exit}}}') || true
      if [[ -z "${AVAHI_IFACE:-}" ]]; then
        AVAHI_IFACE=$(ip -o link show up 2>/dev/null | awk -F': ' '!/ lo:/{print $2; exit}') || true
      fi
    fi
    AVAHI_IFACE=${AVAHI_IFACE:-eth0}
  fi

  if ! resolve_alsa_device; then
    log "ALSA device not found (auto-detect/override)"
    return 2
  fi
  resolve_alsa_mixer || true

  # Best-effort unmute and set a sensible volume on the chosen mixer
  if command -v amixer >/dev/null 2>&1 && [[ -n "${ALSA_CARD:-}" && -n "${ALSA_MIXER:-}" ]]; then
    amixer -c "$ALSA_CARD" sset "$ALSA_MIXER" 80% unmute >/dev/null 2>&1 || true
  fi

  # shairport-sync (render into tmp and request a restart via transient unit if needed)
  local tmp_ss; tmp_ss=$(mktemp -p /var/tmp)
  render_template "$REPO_DIR/cfg/shairport-sync.conf.tmpl" "$tmp_ss"
  if [[ ! -f "/etc/shairport-sync.conf" ]] || ! cmp -s "$tmp_ss" "/etc/shairport-sync.conf"; then
    systemd_run cfg-write -- "/usr/bin/install -m 0644 '$tmp_ss' /etc/shairport-sync.conf"
    changed=1
    systemd_run svc-restart -- "/usr/bin/systemctl restart airplay-shairport"
  fi
  rm -f "$tmp_ss"

  # avahi iface restrict (optional)
  if [[ -f "$REPO_DIR/cfg/avahi/avahi-daemon.conf.d/airplay-wyse.conf.tmpl" ]]; then
    # Render to temp; copy + restart handled via broker if policy later allows.
    local tmp_av; tmp_av=$(mktemp -p /var/tmp)
    render_template "$REPO_DIR/cfg/avahi/avahi-daemon.conf.d/airplay-wyse.conf.tmpl" "$tmp_av"
    if [[ ! -d "/etc/avahi/avahi-daemon.conf.d" ]]; then
      systemd_run cfg-write -- "/usr/bin/install -d -m 0755 /etc/avahi/avahi-daemon.conf.d"
      changed=1
    fi
    if [[ ! -f "/etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf" ]] || ! cmp -s "$tmp_av" "/etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf"; then
      systemd_run cfg-write -- "/usr/bin/install -m 0644 '$tmp_av' /etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf"
      changed=1
      systemd_run svc-restart -- "/usr/bin/systemctl restart airplay-avahi"
    fi
    rm -f "$tmp_av"
  fi

  return $changed
}

check_nqptp_health() {
  # If nqptp is not installed (no unit present), treat as optional OK.
  if ! systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    return 0
  fi
  # Unit exists; ensure it's active
  if ! systemctl is-active --quiet nqptp.service; then
    return 1
  fi
  return 0
}

ptp_ports_busy_note() {
  # If ports 319/320 are already in use and nqptp is inactive, hint at conflict
  if ! command -v ss >/dev/null 2>&1; then return 0; fi
  local out
  out=$(ss -lun 2>/dev/null | grep -E ':(319|320) ' || true)
  if [[ -n "$out" ]] && ! nqptp_active; then
    echo "; ports 319/320 busy by another service"
  fi
}

check_avahi_raop() {
  # Consider healthy if either AirPlay (_airplay._tcp) or RAOP (_raop._tcp)
  # advertises this device by friendly name, with a fallback to hostname.
  command -v avahi-browse >/dev/null || return 0
  local name hostn
  name="${AIRPLAY_NAME:-}"
  hostn="$(host_key)"
  # Try friendly name first (literal, case-insensitive), accept either type
  if avahi-browse -rt _airplay._tcp 2>/dev/null | grep -Fqi -- "$name"; then return 0; fi
  if avahi-browse -rt _raop._tcp 2>/dev/null | grep -Fqi -- "$name"; then return 0; fi
  # Fallback: match hostname appearing in browse output
  if avahi-browse -rt _airplay._tcp 2>/dev/null | grep -Fqi -- "$hostn"; then return 0; fi
  if avahi-browse -rt _raop._tcp 2>/dev/null | grep -Fqi -- "$hostn"; then return 0; fi
  return 1
}

converge_main() {
  ensure_dirs

  # Phase 1: Bootstrap sudo configuration to enable transient root actions
  local bsrc
  set +e
  bootstrap_sudo_config
  bsrc=$?
  set -e
  if [[ $bsrc -eq 4 ]]; then
    emit_health "bootstrap_required" "$EXIT_INV" "sudo NOPASSWD systemd-run not configured" >/dev/null || true
    exit "$EXIT_INV"
  elif [[ $bsrc -eq 1 ]]; then
    emit_health "bootstrap_failed" "$EXIT_INV" "failed to configure sudoers/wrapper" >/dev/null || true
    exit "$EXIT_INV"
  fi

  held_check
  if ! load_inventory; then
    emit_health "invalid_inventory" "$EXIT_INV" "missing inventory file" >/dev/null || true
    exit "$EXIT_INV"
  fi
  if ! verify_signed_tag; then
    emit_health "verify_failed" "$EXIT_VERIFY" "unsigned or invalid tag" >/dev/null || true
    exit "$EXIT_VERIFY"
  fi
  if ! time_sync_ok; then
    emit_health "degraded" "$EXIT_DEGRADED" "time unsynced" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi

  # Package ensure
  PACKAGES_CHANGED=0
  sync_systemd_units || true
  if ! apply_packages; then
    emit_health "pkg_failed" "$EXIT_PKG" "package install/update failed" >/dev/null || true
    exit "$EXIT_PKG"
  fi

  # Phase 2: Ensure RAOP2/AirPlay 2 support
  RAOP2_CHANGED=0
  set +e
  ensure_airplay2_support
  local erc=$?
  set -e
  if [[ $erc -eq $EXIT_PKG ]]; then
    emit_health "pkg_failed" "$EXIT_PKG" "failed to ensure AirPlay 2 support" >/dev/null || true
    exit "$EXIT_PKG"
  elif [[ $erc -eq $EXIT_CHANGED ]]; then
    RAOP2_CHANGED=1
  fi

  # Keep nqptp and shairport override in sync
  ensure_nqptp_started || true
  sync_shairport_override || true

  # Apply configs and possibly restart services
  set +e
  apply_configs
  local cfg_rc=$?
  set -e
  if [[ $cfg_rc -eq 2 ]]; then
    emit_health "degraded" "$EXIT_DEGRADED" "alsa device missing" >/dev/null || true
    exit "$EXIT_DEGRADED"
  elif [[ $cfg_rc -eq 3 ]]; then
    emit_health "systemd_failed" "$EXIT_SYSTEMD" "service restart failed" >/dev/null || true
    exit "$EXIT_SYSTEMD"
  fi

  # If this run applied changes, report CHANGED and skip health checks
  if [[ $cfg_rc -eq 1 || ${PACKAGES_CHANGED:-0} -eq 1 || ${RAOP2_CHANGED:-0} -eq 1 ]]; then
    emit_health "healthy_changed" "$EXIT_CHANGED" "changes applied or enqueued root ops" >/dev/null || true
    exit "$EXIT_CHANGED"
  fi

  # Health checks (only when no changes in this run)
  if ! check_nqptp_health; then
    local note
    note=$(ptp_ports_busy_note || true)
    emit_health "degraded" "$EXIT_DEGRADED" "nqptp not healthy${note}" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  if ! has_raop2; then
    log "WARN: shairport-sync lacks AirPlay 2 (RAOP2) support - install RAOP2-enabled build"
    emit_health "degraded" "$EXIT_DEGRADED" "shairport-sync lacks AirPlay 2 (RAOP2); install RAOP2-enabled build" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  if ! check_avahi_raop; then
    emit_health "degraded" "$EXIT_DEGRADED" "avahi/raop not visible" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  emit_health "healthy" "$EXIT_OK" "no changes" >/dev/null || true
  exit "$EXIT_OK"
}

main() { converge_main "$@"; }

main "$@"
