#!/usr/bin/env bash
set -euo pipefail

# AirPlay Wyse converge orchestrator (minimal, idempotent)

REPO_DIR="/opt/airplay_wyse"
STATE_DIR="/var/lib/airplay_wyse"
RUN_DIR="/run/airplay"
ETC_DIR="/etc/airplay_wyse"
TMPDIR="/run/airplay/tmp"

EXIT_OK=0
EXIT_CHANGED=2
EXIT_DEGRADED=3
EXIT_INV=4
EXIT_VERIFY=5
EXIT_HELD=6
EXIT_PKG=10
EXIT_SYSTEMD=11

log() { echo "$(date --iso-8601=seconds) [converge] $*"; }
fail() { log "ERROR: $*"; exit 1; }

# No privilege escalation needed - running as root via systemd

# Bootstrap logic removed: wrapper/sudoers must be preinstalled.

ensure_dirs() {
  # State dir may be created by provisioning; create lazily if writable.
  mkdir -p "$STATE_DIR" 2>/dev/null || true
  mkdir -p "$STATE_DIR/hashes" 2>/dev/null || true
  
  # Create temp directory in writable location (Wyse has read-only /tmp and /var/tmp)
  if [[ ! -d "$TMPDIR" ]]; then
    install -d -m 0755 /run/airplay
    install -d -m 0755 "$TMPDIR"
  fi
  
  # Ensure temp directory is writable
  if [[ ! -w "$TMPDIR" ]]; then
    log "WARN: temp directory $TMPDIR not writable, using fallback"
    TMPDIR="/tmp/airplay-$$"
    mkdir -p "$TMPDIR" 2>/dev/null || TMPDIR="/dev/shm/airplay-$$"
    mkdir -p "$TMPDIR" 2>/dev/null || TMPDIR="."
  fi
}

# GitOps: ensure systemd units on device match repo.
sync_systemd_units() {
  local changed=0
  # Ensure systemd units on device match repo; avoid shadowing vendor units

  for src in "$REPO_DIR"/systemd/*.service "$REPO_DIR"/systemd/*.path; do
    [[ -f "$src" ]] || continue
    local base dest
    base=$(basename "$src")
    # Do not override vendor-provided nqptp unit (APT installs one under /lib/systemd)
    if [[ "$base" == "nqptp.service" ]]; then
      continue
    fi
    dest="/etc/systemd/system/$base"
    if [[ ! -f "$dest" ]] || ! cmp -s "$src" "$dest"; then
      install -m 0644 "$src" "$dest"
      changed=1
    fi
  done
  # Ensure converge drop-in override mirrors SuccessExitStatus
  local conv_ov_src="$REPO_DIR/systemd/overrides/converge.service.d/override.conf"
  if [[ -f "$conv_ov_src" ]]; then
    install -d -m 0755 /etc/systemd/system/converge.service.d
    install -m 0644 "$conv_ov_src" /etc/systemd/system/converge.service.d/override.conf
    changed=1
  fi
  if [[ $changed -eq 1 ]]; then
    systemctl daemon-reload
    # Log SuccessExitStatus configured for converge.service for verification
    local ses
    ses=$(systemctl show -p SuccessExitStatus --value converge.service 2>/dev/null || echo)
    log "converge.service SuccessExitStatus='${ses}'"
  fi
  # Remove deprecated units (.path and broker) if present
  local obsolete=(
    /etc/systemd/system/update-done.path
    /etc/systemd/system/converge-broker.path
    /etc/systemd/system/converge-broker.service
  )
  local removed=0 u
  for u in "${obsolete[@]}"; do
    if [[ -f "$u" ]]; then
      local uname; uname=$(basename "$u")
      systemctl stop "$uname" || true
      systemctl disable "$uname" || true
      rm -f "$u"
      removed=1
    fi
  done
  if [[ $removed -eq 1 ]]; then
    systemctl daemon-reload
  fi
}

emit_health() {
  local status="$1" code="$2" reason="$3"
  local json
  # Optional capability booleans (may be unset early)
  local has_raop2_val=${HEALTH_RAOP2:-}
  local nqptp_inst_val=${HEALTH_NQPTP_INSTALLED:-}
  local nqptp_active_val=${HEALTH_NQPTP_ACTIVE:-}
  local version
  version=$(cat "$REPO_DIR/VERSION" 2>/dev/null || echo unknown)
  if command -v jq >/dev/null 2>&1; then
    json=$(jq -n \
      --arg status "$status" \
      --arg reason "$reason" \
      --arg version "$version" \
      --argjson raop2 "${has_raop2_val:-null}" \
      --argjson nqptp_installed "${nqptp_inst_val:-null}" \
      --argjson nqptp_active "${nqptp_active_val:-null}" \
      '{status:$status, reason:$reason, version:$version, shairport_has_raop2:$raop2, nqptp_installed:$nqptp_installed, nqptp_active:$nqptp_active, ts: now|tojson}') || json="{}"
  else
    # Fallback JSON without jq (minimal but valid)
    # Note: booleans may be omitted when not set
    json='{'
    json+="\"status\":\"$status\",\"reason\":\"$reason\",\"version\":\"$version\""
    if [[ "${has_raop2_val:-}" == "true" || "${has_raop2_val:-}" == "false" ]]; then
      json+=",\"shairport_has_raop2\":${has_raop2_val}"
    fi
    if [[ "${nqptp_inst_val:-}" == "true" || "${nqptp_inst_val:-}" == "false" ]]; then
      json+=",\"nqptp_installed\":${nqptp_inst_val}"
    fi
    if [[ "${nqptp_active_val:-}" == "true" || "${nqptp_active_val:-}" == "false" ]]; then
      json+=",\"nqptp_active\":${nqptp_active_val}"
    fi
    json+='}'
  fi
  local tmpj; tmpj=$(mktemp -p "$TMPDIR")
  printf "%s\n" "$json" >"$tmpj"
  install -m 0644 "$tmpj" "$STATE_DIR/last-health.json" 2>/dev/null || true
  rm -f "$tmpj"
  local tmpt; tmpt=$(mktemp -p "$TMPDIR")
  echo "status=$status code=$code reason=$reason" >"$tmpt"
  install -m 0644 "$tmpt" "$STATE_DIR/last-health.txt" 2>/dev/null || true
  rm -f "$tmpt"
  return "$code"
}

host_key() {
  hostname -s | tr '[:upper:]' '[:lower:]'
}

# GPG verification is performed in bin/update. Converge does not re-verify tags.

held_check() {
  if [[ -f "$ETC_DIR/hold" || -f "$STATE_DIR/hold" ]]; then
    emit_health "held" "$EXIT_HELD" "hold file present" >/dev/null || true
    exit "$EXIT_HELD"
  fi
}

load_inventory() {
  local host=$(host_key)
  local inv="$REPO_DIR/inventory/hosts/${host}.yml"
  if [[ -f "$inv" ]]; then
    INVENTORY_FILE="$inv"
    return 0
  fi
  log "inventory missing for host $host; proceeding with auto-detect defaults"
  INVENTORY_FILE=""
  return 0
}

yaml_get() {
  # very small helper to extract simple key: value (no nesting beyond one dot)
  local key="$1"
  if [[ -n "${INVENTORY_FILE:-}" && -f "$INVENTORY_FILE" ]]; then
    grep -E "^${key}:[[:space:]]" "$INVENTORY_FILE" | sed -E "s/^${key}:[[:space:]]*//" | tr -d '"'
  else
    echo ""
  fi
}

time_sync_ok() {
  local ntp sys
  ntp=$(timedatectl show -p NTPSynchronized --value 2>/dev/null || echo no)
  sys=$(timedatectl show -p SystemClockSynchronized --value 2>/dev/null || echo no)
  [[ "$ntp" == "yes" || "$sys" == "yes" ]]
}

sha256_file() { sha256sum "$1" | awk '{print $1}'; }

render_template() {
  # Simple placeholder replacement using envsubst-style variables
  local src="$1" dst="$2"
  local tmp
  tmp=$(mktemp -p "$TMPDIR")
  cp "$src" "$tmp"
  sed -i "s/{{AIRPLAY_NAME}}/${AIRPLAY_NAME//\//\/}/g" "$tmp"
  sed -i "s/{{ALSA_DEVICE}}/${ALSA_DEVICE//\//\/}/g" "$tmp"
  sed -i "s/{{AVAHI_IFACE}}/${AVAHI_IFACE//\//\/}/g" "$tmp"
  sed -i "s/{{ALSA_MIXER}}/${ALSA_MIXER//\//\/}/g" "$tmp"
  # Write rendered file to a temp path owned by airplay; a root copy, if needed, must be enqueued externally.
  install -m 0644 "$tmp" "$dst" 2>/dev/null || true
  rm -f "$tmp"
}

# removed unused helpers: needs_update, resolve_alsa_device

# Determine ALSA mixer control with override and sensible defaults
resolve_alsa_mixer() {
  local inv_mix
  inv_mix=$(yaml_get 'alsa.mixer' || true)
  if [[ -n "${inv_mix:-}" ]]; then
    ALSA_MIXER="$inv_mix"
    return 0
  fi
  ALSA_MIXER="Digital"
  if command -v amixer >/dev/null 2>&1 && [[ -n "${ALSA_CARD:-}" ]]; then
    local names
    names=$(amixer -c "$ALSA_CARD" scontrols 2>/dev/null | awk -F"'" '/Simple mixer control/ {print $2}') || names=""
    local cand
    for cand in PCM Master Digital Speaker Headphone "Line Out" Line Front; do
      if echo "$names" | grep -qx "$cand"; then
        ALSA_MIXER="$cand"; break
      fi
    done
  fi
  return 0
}

# Removed duplicate package ensure; see ensure_ap2_packages()/ensure_airplay2_support.

sync_shairport_override() {
  # Ensure shairport-sync has an override to order after nqptp and tighten sandbox
  local src="$REPO_DIR/systemd/overrides/shairport-sync.service.d/override.conf"
  local changed=0
  if [[ -f "$src" ]]; then
    if [[ ! -d "/etc/systemd/system/shairport-sync.service.d" ]]; then
      install -d -m 0755 /etc/systemd/system/shairport-sync.service.d
      changed=1
    fi
    local dest="/etc/systemd/system/shairport-sync.service.d/override.conf"
    if [[ ! -f "$dest" ]] || ! cmp -s "$src" "$dest"; then
      install -m 0644 "$src" "$dest"
      changed=1
    fi
  fi
  if [[ $changed -eq 1 ]]; then
    systemctl daemon-reload
    systemctl restart shairport-sync.service
  fi
  return $changed
}

ensure_nqptp_started() {
  # If nqptp service exists, ensure it's enabled and started via transient privileged unit
  if systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    if ! systemctl is-enabled --quiet nqptp.service 2>/dev/null; then
      systemctl enable nqptp.service
    fi
    if ! systemctl is-active --quiet nqptp.service 2>/dev/null; then
      systemctl start nqptp.service
    fi
  fi
}

has_airplay2_build() {
  if ! command -v shairport-sync >/dev/null 2>&1; then return 1; fi
  local v
  v=$(shairport-sync -V 2>&1 || true)
  log "Checking shairport-sync for AirPlay 2 support: $(echo "$v" | head -1)"
  echo "$v" | grep -q "AirPlay2" && return 0 || return 1
}

# Compatibility wrapper: preferred name
has_raop2() { has_airplay2_build; }

# nqptp activity check
nqptp_active() { systemctl is-active --quiet nqptp.service 2>/dev/null; }

nqptp_installed() {
  systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"
}

# Removed build/install-from-source helpers (immutable-ish hosts). APT-only.

ensure_ap2_packages() {
  local changed=0

  # Determine if we need packages
  local needs_install=0
  if ! command -v shairport-sync >/dev/null 2>&1; then
    needs_install=1
  elif ! shairport-sync -V 2>&1 | grep -q "AirPlay2"; then
    needs_install=1
  fi
  if ! systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    needs_install=1
  fi

  if [[ $needs_install -eq 1 ]]; then
    log "Ensuring AirPlay 2 packages via APT (shairport-sync, nqptp)..."
    local did_update=0
    apt_update() {
      if [[ $did_update -eq 0 ]]; then
        apt-get update -y || return 1
        did_update=1
      fi
    }
    ensure_pkg() {
      local pkg="$1"
      if ! dpkg -s "$pkg" >/dev/null 2>&1; then
        apt_update || return 1
        DEBIAN_FRONTEND=noninteractive apt-get -y install "$pkg" || return 1
      fi
    }
    if ! ensure_pkg shairport-sync || ! ensure_pkg nqptp; then
      log "APT install failed for required packages"
      return 100
    fi
    changed=1
  fi

  echo $changed
  return 0
}

# Remediate missing RAOP2 capability (install/start nqptp; upgrade shairport-sync)
remediate_raop2() {
  local changed=0
  local ovsrc="$REPO_DIR/systemd/overrides/shairport-sync.service.d/override.conf"
  local ovdst="/etc/systemd/system/shairport-sync.service.d/override.conf"

  # Ensure override exists and only mark changed when content differs
  if [[ -f "$ovsrc" ]]; then
    install -d -m 0755 /etc/systemd/system/shairport-sync.service.d
    if [[ ! -f "$ovdst" ]] || ! cmp -s "$ovsrc" "$ovdst"; then
      install -m 0644 "$ovsrc" "$ovdst"
      changed=1
    fi
  fi

  # Reload systemd only if override changed
  if [[ $changed -eq 1 ]]; then
    systemctl daemon-reload || true
  fi

  # Ensure nqptp is enabled and started; avoid restarts if already active
  if systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    if ! systemctl is-enabled --quiet nqptp.service 2>/dev/null; then
      systemctl enable nqptp.service || true
      changed=1
    fi
    if ! systemctl is-active --quiet nqptp.service 2>/dev/null; then
      systemctl start nqptp.service || true
      changed=1
    fi
  fi

  # Restart shairport only if override changed
  if [[ $changed -eq 1 ]]; then
    systemctl restart shairport-sync.service || true
  fi

  echo $changed
}

# Ensure AirPlay 2 (RAOP2) support by installing/activating nqptp and a RAOP2-capable shairport-sync
# Returns: 0 (no change), 2 (changed), 10 (package error)
ensure_airplay2_support() {
  local changed=0
  log "Checking AirPlay 2 support status..."
  local pc
  pc=$(ensure_ap2_packages || echo 100)
  if [[ "$pc" == "100" ]]; then
    return $EXIT_PKG
  fi
  if [[ "$pc" -ne 0 ]]; then changed=1; fi
  local rc
  rc=$(remediate_raop2 || echo 0)
  if [[ "$rc" -ne 0 ]]; then changed=1; fi
  if [[ $changed -eq 1 ]]; then return $EXIT_CHANGED; fi
  return $EXIT_OK
}

apply_configs() {
  local changed=0
  AIRPLAY_NAME=$(yaml_get 'airplay_name')
  AVAHI_IFACE=$(yaml_get 'nic')

  # Defaults if inventory missing/empty
  AIRPLAY_NAME=${AIRPLAY_NAME:-$(host_key)}
  if [[ -z "${AVAHI_IFACE:-}" ]]; then
    # Prefer default route device; fallback to first non-lo UP interface
    if command -v ip >/dev/null 2>&1; then
      AVAHI_IFACE=$(ip -o route show default 2>/dev/null | awk '{for(i=1;i<=NF;i++){if($i=="dev"){print $(i+1); exit}}}') || true
      if [[ -z "${AVAHI_IFACE:-}" ]]; then
        AVAHI_IFACE=$(ip -o link show up 2>/dev/null | awk -F': ' '!/ lo:/{print $2; exit}') || true
      fi
    fi
    AVAHI_IFACE=${AVAHI_IFACE:-eth0}
  fi

  # Probe ALSA device via helper
  local probe_out
  if ! probe_out=$("$REPO_DIR/bin/alsa-probe" 2>/dev/null); then
    log "ALSA device not found"
    return 2
  fi
  ALSA_DEVICE="$probe_out"
  # Derive ALSA_CARD index from ALSA_DEVICE (format: hw:<card>,<dev>)
  ALSA_CARD=$(echo "$ALSA_DEVICE" | sed -n 's/^hw:\([0-9]\+\),.*/\1/p')
  resolve_alsa_mixer || true

  # Best-effort unmute and set a sensible volume on the chosen mixer
  if command -v amixer >/dev/null 2>&1 && [[ -n "${ALSA_CARD:-}" && -n "${ALSA_MIXER:-}" ]]; then
    amixer -c "$ALSA_CARD" sset "$ALSA_MIXER" 80% unmute >/dev/null 2>&1 || true
  fi

  # shairport-sync (render into tmp and request a restart via transient unit if needed)
  local tmp_ss; tmp_ss=$(mktemp -p "$TMPDIR")
  render_template "$REPO_DIR/cfg/shairport-sync.conf.tmpl" "$tmp_ss"
  if [[ -z "${ALSA_MIXER:-}" ]]; then
    sed -i "/mixer_control_name/d" "$tmp_ss"
  fi
  if [[ ! -f "/etc/shairport-sync.conf" ]] || ! cmp -s "$tmp_ss" "/etc/shairport-sync.conf"; then
    install -m 0644 "$tmp_ss" /etc/shairport-sync.conf
    changed=1
    systemctl restart shairport-sync.service || true
  fi
  rm -f "$tmp_ss"

  # avahi iface restrict (optional)
  if [[ -f "$REPO_DIR/cfg/avahi/avahi-daemon.conf.d/airplay-wyse.conf.tmpl" ]]; then
    # Render to temp; copy + restart handled via broker if policy later allows.
    local tmp_av; tmp_av=$(mktemp -p "$TMPDIR")
    render_template "$REPO_DIR/cfg/avahi/avahi-daemon.conf.d/airplay-wyse.conf.tmpl" "$tmp_av"
    if [[ ! -d "/etc/avahi/avahi-daemon.conf.d" ]]; then
      install -d -m 0755 /etc/avahi/avahi-daemon.conf.d
      changed=1
    fi
    if [[ ! -f "/etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf" ]] || ! cmp -s "$tmp_av" "/etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf"; then
      install -m 0644 "$tmp_av" /etc/avahi/avahi-daemon.conf.d/airplay-wyse.conf
      changed=1
      systemctl restart avahi-daemon.service || true
    fi
    rm -f "$tmp_av"
  fi

  return $changed
}

check_nqptp_health() {
  # If nqptp is not installed (no unit present), treat as optional OK.
  if ! systemctl list-unit-files --type=service --no-legend 2>/dev/null | awk '{print $1}' | grep -qx "nqptp.service"; then
    return 0
  fi
  # Unit exists; ensure it's active
  if ! systemctl is-active --quiet nqptp.service; then
    return 1
  fi
  return 0
}

ptp_ports_busy_note() {
  # If ports 319/320 are already in use and nqptp is inactive, hint at conflict
  if ! command -v ss >/dev/null 2>&1; then return 0; fi
  local out
  out=$(ss -lun 2>/dev/null | grep -E ':(319|320) ' || true)
  if [[ -n "$out" ]] && ! nqptp_active; then
    echo "; ports 319/320 busy by another service"
  fi
}

check_avahi_raop() {
  # Consider healthy if either AirPlay (_airplay._tcp) or RAOP (_raop._tcp)
  # advertises this device by friendly name, with a fallback to hostname.
  command -v avahi-browse >/dev/null || return 0
  local name hostn browse_out
  name="${AIRPLAY_NAME:-}"
  hostn="$(host_key)"
  
  # Get browse output for both service types
  browse_out=$(timeout 5 avahi-browse -rt _airplay._tcp 2>/dev/null || true)
  if [[ -n "$browse_out" ]]; then
    # Ensure our specific device name appears in AirPlay advertisements
    if echo "$browse_out" | grep -F "_airplay._tcp" | grep -Fqi -- "$name"; then return 0; fi
    if echo "$browse_out" | grep -F "_airplay._tcp" | grep -Fqi -- "$hostn"; then return 0; fi
  fi
  
  # Fallback to RAOP if AirPlay not found
  browse_out=$(timeout 5 avahi-browse -rt _raop._tcp 2>/dev/null || true)
  if [[ -n "$browse_out" ]]; then
    if echo "$browse_out" | grep -F "_raop._tcp" | grep -Fqi -- "$name"; then return 0; fi
    if echo "$browse_out" | grep -F "_raop._tcp" | grep -Fqi -- "$hostn"; then return 0; fi
  fi
  
  return 1
}

converge_main() {
  ensure_dirs

  # Root-run model: no systemd-run dependency

  held_check
  if ! load_inventory; then
    emit_health "invalid_inventory" "$EXIT_INV" "missing inventory file" >/dev/null || true
    exit "$EXIT_INV"
  fi
  # Tag verification handled in bin/update; skip here for efficiency.
  if ! time_sync_ok; then
    emit_health "degraded" "$EXIT_DEGRADED" "time unsynced" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi

  # Ensure systemd units and proceed to package + RAOP2 support
  sync_systemd_units || true

  # Phase 2: Ensure RAOP2/AirPlay 2 support
  RAOP2_CHANGED=0
  set +e
  ensure_airplay2_support
  local erc=$?
  set -e
  if [[ $erc -eq $EXIT_PKG ]]; then
    emit_health "pkg_failed" "$EXIT_PKG" "failed to ensure AirPlay 2 support" >/dev/null || true
    exit "$EXIT_PKG"
  elif [[ $erc -eq $EXIT_CHANGED ]]; then
    RAOP2_CHANGED=1
  fi

  # Keep nqptp and shairport override in sync
  ensure_nqptp_started || true
  sync_shairport_override || true

  # Apply configs and possibly restart services
  set +e
  apply_configs
  local cfg_rc=$?
  set -e
  if [[ $cfg_rc -eq 2 ]]; then
    emit_health "degraded" "$EXIT_DEGRADED" "alsa device missing" >/dev/null || true
    exit "$EXIT_DEGRADED"
  elif [[ $cfg_rc -eq 3 ]]; then
    emit_health "systemd_failed" "$EXIT_SYSTEMD" "service restart failed" >/dev/null || true
    exit "$EXIT_SYSTEMD"
  fi

  # If this run applied changes, report CHANGED and skip health checks
  if [[ $cfg_rc -eq 1 || ${RAOP2_CHANGED:-0} -eq 1 ]]; then
    emit_health "healthy_changed" "$EXIT_CHANGED" "changes applied or enqueued root ops" >/dev/null || true
    exit "$EXIT_CHANGED"
  fi

  # Health checks (only when no changes in this run)
  HEALTH_RAOP2=$(has_raop2 && echo true || echo false)
  HEALTH_NQPTP_INSTALLED=$(nqptp_installed && echo true || echo false)
  HEALTH_NQPTP_ACTIVE=$(nqptp_active && echo true || echo false)
  if ! check_nqptp_health; then
    local note
    note=$(ptp_ports_busy_note || true)
    emit_health "degraded" "$EXIT_DEGRADED" "nqptp not healthy${note}" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  if ! has_raop2; then
    log "WARN: shairport-sync lacks AirPlay 2 (RAOP2) support - install RAOP2-enabled build"
    emit_health "degraded" "$EXIT_DEGRADED" "shairport-sync lacks AirPlay 2 (RAOP2); install RAOP2-enabled build" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  if ! check_avahi_raop; then
    emit_health "degraded" "$EXIT_DEGRADED" "avahi/raop not visible" >/dev/null || true
    exit "$EXIT_DEGRADED"
  fi
  emit_health "healthy" "$EXIT_OK" "no changes" >/dev/null || true
  exit "$EXIT_OK"
}

main() { converge_main "$@"; }

main "$@"
