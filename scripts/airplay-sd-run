#!/usr/bin/env bash
set -euo pipefail

# AirPlay Wyse Privilege Escalation Wrapper
# Secure systemd-run wrapper with profile-based access control
# Usage: airplay-sd-run <command> [args...]

readonly SCRIPT_NAME="$(basename "$0")"
readonly LOG_PREFIX="[airplay-sd-run]"

log() {
    logger -t "$SCRIPT_NAME" "$*"
    echo "$LOG_PREFIX $*" >&2
}

die() {
    log "ERROR: $*"
    exit 1
}

# Validate command is absolute path and executable
validate_command() {
    local cmd="$1"
    
    # Must be absolute path
    [[ "$cmd" =~ ^/ ]] || die "Command must be absolute path: $cmd"
    
    # Must exist and be executable
    [[ -x "$cmd" ]] || die "Command not found or not executable: $cmd"
    
    # Allowlist of permitted executables
    case "$cmd" in
        /usr/bin/apt-get|\
        /usr/bin/dpkg|\
        /usr/bin/systemctl|\
        /usr/bin/install|\
        /usr/bin/tee|\
        /usr/sbin/useradd|\
        /bin/rm|\
        /bin/mkdir)
            return 0
            ;;
        *)
            die "Command not in allowlist: $cmd"
            ;;
    esac
}

# Optional: basic validation of systemctl invocations
validate_systemctl_args() {
    # Require a known action as the first argument
    local action="$1"; shift || true
    case "$action" in
        enable|disable|start|stop|restart|daemon-reload)
            return 0
            ;;
        *)
            die "systemctl action not permitted: ${action:-<none>}"
            ;;
    esac
}

# Determine systemd security profile based on command
get_security_profile() {
    local cmd="$1"
    
    case "$cmd" in
        /usr/bin/apt-get|/usr/bin/dpkg)
            # Package management needs network access
            echo "pkg"
            ;;
        /usr/bin/systemctl)
            # Service management
            echo "systemd"
            ;;
        /usr/bin/install|/bin/rm|/bin/mkdir|/usr/bin/tee)
            # File operations
            echo "file"
            ;;
        *)
            echo "default"
            ;;
    esac
}

# Build systemd-run command with security properties
build_systemd_run() {
    local profile="$1"
    shift
    
    local -a props=(
        "--wait"
        "--collect" 
        "--quiet"
        "--uid=0"
        "--gid=0"
        "--property=Type=exec"
        "--property=NoNewPrivileges=yes"
        "--property=ProtectSystem=strict"
        "--property=ProtectHome=yes"
        "--property=PrivateTmp=yes"
        "--property=MemoryDenyWriteExecute=yes"
        "--property=SystemCallFilter=@system-service"
        "--property=SystemCallFilter=~@privileged"
        "--property=SystemCallFilter=~@resources"
        "--property=CapabilityBoundingSet="
        "--property=AmbientCapabilities="
    )
    
    # Profile-specific properties
    case "$profile" in
        "pkg")
            # Package installs need broad write access; keep syscall and tmp/home protections relaxed.
            # Do not restrict ReadWritePaths for dpkg to function correctly.
            props+=(
                "--property=RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6"
                "--property=ProtectSystem=off"
                "--property=ProtectHome=false"
            )
            ;;
        "systemd")
            props+=(
                "--property=RestrictAddressFamilies=AF_UNIX"
                "--property=ReadWritePaths=/etc/systemd /run/systemd"
            )
            ;;
        "file")
            props+=(
                "--property=RestrictAddressFamilies=AF_UNIX"
                "--property=ReadWritePaths=/etc /var"
            )
            ;;
        *)
            props+=(
                "--property=RestrictAddressFamilies=AF_UNIX"
                "--property=ReadWritePaths=/var"
            )
            ;;
    esac
    
    # Execute via systemd-run
    systemd-run "${props[@]}" -- "$@"
}

main() {
    [[ $# -gt 0 ]] || die "Usage: $SCRIPT_NAME <command> [args...]"
    
    local cmd="$1"
    validate_command "$cmd"
    
    local profile
    profile=$(get_security_profile "$cmd")

    log "Executing: $* (profile: $profile)"

    if [[ "$cmd" == "/usr/bin/systemctl" ]]; then
        # Validate systemctl subcommand is within allowlist
        [[ $# -ge 2 ]] || die "systemctl requires an action"
        shift  # drop cmd path; next is action
        validate_systemctl_args "$1"
        # Rebuild argv with cmd path restored for execution
        set -- "/usr/bin/systemctl" "$@"
    fi

    # Execute with appropriate security profile
    build_systemd_run "$profile" "$@"
    local exit_code=$?
    
    log "Command completed with exit code: $exit_code"
    return $exit_code
}

main "$@"
